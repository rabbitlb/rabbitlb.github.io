<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rabbit_lb&#39;s Blog</title>
  
  <subtitle>Hello World!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.rabbit-lb.cn/"/>
  <updated>2018-08-21T16:00:00.000Z</updated>
  <id>http://blog.rabbit-lb.cn/</id>
  
  <author>
    <name>rabbit_lb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>特征根法、斐波那契数列和几个证明</title>
    <link href="http://blog.rabbit-lb.cn/2018/08/22/%E7%89%B9%E5%BE%81%E6%A0%B9%E6%B3%95%E5%92%8C%E5%AE%83%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AF%81%E6%98%8E/"/>
    <id>http://blog.rabbit-lb.cn/2018/08/22/特征根法和它的几个证明/</id>
    <published>2018-08-21T16:00:00.000Z</published>
    <updated>2018-08-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>特征根法是解决常系数齐次线性递推通项问题的通用做法。它十分普及，因为它简单好记。本文先简单介绍特征根法，然后给出几个证明。</p><h1 id="齐次线性递推"><a href="#齐次线性递推" class="headerlink" title="齐次线性递推"></a>齐次线性递推</h1><p>我们先来看一下齐次线性递推的概念。我们定义 $k$ 阶的齐次线性递推应该长这个样子：</p><blockquote><p>对任意 $n \in \mathbb{N}$，有 $a_{n+k} = c_1 a_{n+k-1} + c_2 a_{n+k-2} + \cdots + c_k a_n$ ，其中 $c_1 , c_2 , \cdots , c_k \in \mathbb{R}$</p></blockquote><p>为了顺利推出每一项，这个递推还应该给出 $k$ 个初值 $a_0,a_1,a_2,\cdots,a_{k-1}$ 。 </p><p>对了，在本文中，若未特别提及线性递推均为 $k$ 阶齐次线性递推。</p><h1 id="特征根法"><a href="#特征根法" class="headerlink" title="特征根法"></a>特征根法</h1><p>对于上面那个递推式，我们定义它的<em>特征方程</em>为：</p><blockquote><p>$\lambda^k=c_1 \lambda^{k-1} +c_2 \lambda^{k-2} + \cdots + c_{k-1} \lambda +c_k$</p></blockquote><p>这个方程有 $k$ 个根 $\lambda_1,\lambda_2,…,\lambda_k$ ，它们也许有些不是实数但没有关系。那么我们宣称数列 $\{a_n\}$ 的通项为</p><center>$a_n=p_1\lambda_1^n+p_2\lambda_2^n+\cdots+p_k\lambda_k^n$ </center><p>其中 $p_1,p_2,…,p_k$ 是待定的系数，通过把初值 $n=0,1,2,…,k-1$ 带入后，可以解出 $p_1,p_2,…,p_k$ 。</p><h2 id="重根的情况"><a href="#重根的情况" class="headerlink" title="重根的情况"></a>重根的情况</h2><p>重根的情况相对复杂。打个比方，假设 $\lambda_1=\lambda_2=\lambda_3$ 的话。我们只需要把原来设的通项中的 $p_1\lambda_1^n+p_2\lambda_2^n+p_3\lambda_3^n$ 改为 $(p_1n^2+p_2n+p_3)\lambda_1^n$ 就好了。具体来说就是，如果某个根有 $m$ 个重根，就设一个 $m-1$ 次的多项式乘上这个根的 $n$ 次方，不明白的可以再看看上面的例子。</p><h2 id="举个例子————斐波那契数列"><a href="#举个例子————斐波那契数列" class="headerlink" title="举个例子————斐波那契数列"></a>举个例子————斐波那契数列</h2><p>斐波那契数列 $\{f_n\}$ 满足递推关系 $f_{n+2}=f_{n+1}+f_n$ ，且有初值 $f_0=0$,$f_1=1$ 。求它的通项当然可以通过构造等比数列或者求生成函数的方法来求，但在这里，特征根法是最简单的一种。<br><a id="more"></a><br>我们通过定义可以得出斐波那契数列的特征方程是：</p><center>$\lambda^2=\lambda+1$ </center><p>解出来：</p><center>$\lambda_1=\phi=\frac{\sqrt5+1}{2}$ , $\lambda_2=1-\phi=\frac{1-\sqrt5}{2}$ </center><p>于是我们设通项为：</p><center>$f_n=p_1\phi^n + p_2(1-\phi)^n$ </center><p>带入 $n=0,1$ 得到：</p><center>$\begin{cases}p_1 + p_2 = 0\\ \frac{\sqrt5+1}{2}p_1 + \frac{1-\sqrt5}{2}p_2 = 1 \end{cases}$ $\Rightarrow \begin{cases}p_1 = \frac{1}{\sqrt5}\\p_2 = -\frac{1}{\sqrt5} \end{cases}$ </center><p>故 $f_n= \frac{1}{\sqrt5}(\phi^n-(1-\phi)^n) $<br>即 $f_n= \frac{1}{\sqrt5}((\frac{\sqrt5+1}{2})^n-(\frac{1-\sqrt5}{2})^n)$</p><p>代几个值试试，神奇吧。</p><h1 id="一个简单的证明"><a href="#一个简单的证明" class="headerlink" title="一个简单的证明"></a>一个简单的证明</h1><p>就拿斐波那契数列来举例子。斐波那契数列需要满足两个条件，一个是递推式 $f_{n+2}=f_{n+1}+f_n$ ，另一个是初值 $f_0=0,f_1=1$ 。满足这两个条件的数列是惟一的，那就是斐波那契数列。</p><p>我们先着眼于第一个条件——递推式。满足这个递推式的数列多种多样。理论上来说，只要随便确定初值 $f_0,f_1$ 都能生成一个满足这样递推式的数列。我们来尝试给两个初值，就 $f_0=1$ 和 $f_1=\phi$ 吧，看看会发生什么。</p><center>$f_2=f_1+f_0=\phi+1=\phi^2$ </center><center>$f_3=f_2+f_1=\phi^2+\phi=\phi^3$ </center><center>$f_4=f_3+f_2=\phi^3+\phi^2=\phi^4$ </center><center>...</center><center>$f_n=f_{n-1}+f_{n-2}=\phi^{n-1}+\phi^{n-2}=\phi^n$ </center><p><strong>等比数列！</strong></p><p>容易验证，数列 $\{1,1-\phi,(1-\phi)^2,…\}$ 也是一个满足递推式 $f_{n+2}=f_{n+1}+f_n$ 的等比数列。因为他们都是特征方程 $\lambda^2=\lambda+1$ 的根。</p><p>我们还知道一些性质，他们是显而易见的。比方说一个数列满足某个递推式，那么将数列中每个数都乘上一个常数，数列依旧满足这个递推式。再比方说如果都两个数列满足同一个递推式，那么他们的和，差（就是对应的数相加，减），也满足这个递推式。</p><p>形式化地，如果数列 $\{a_n\}$ 满足某个递推式，那么数列 $\{ka_n\}$ 也满足这个递推式，其中 $k \in \mathbb{C}$。</p><p>如果数列 $\{a_n\},\{b_n\}$ 满足某个递推式，那么数列 $\{a_n+b_n\}$ 也满足这个递推式。</p><p>下面，我们要进行一番操作了。</p><p>对于递推式 $f_{n+2}=f_{n+1}+f_n$,我们发现了两个等比数列满足这个递推式，他们的公比是方程 $\lambda^2=\lambda+1$ 的两个根 $\phi$ 和 $1-\phi$ 。但我们还需要满足初值条件 $f_0=0,f_1=1$。</p><p>我们已经知道了，我们对这两个等比数列加加减减，或者让他们各自乘上一个常数，得到的新数列依然满足递推式。于是我们尝试利用两个数列，组合出真正的斐波那契数列 $\{f_n\}$ 。</p><p>显然我们可以将两个数列分别乘上一个常数，然后加起来。如果加起来之后的新数列前两项满足初值条件 $f_0=0,f_1=1$ ，就大功告成了。我们假设两个数列分别乘常数 $p_1,p_2$ ，为了满足初值条件，我们可以得到</p><center>$\begin{cases}p_1 + p_2 = 0\\ \frac{\sqrt5+1}{2}p_1 + \frac{1-\sqrt5}{2}p_2 = 1 \end{cases}$ $\Rightarrow \begin{cases}p_1 = \frac{1}{\sqrt5}\\p_2 = -\frac{1}{\sqrt5} \end{cases}$ </center><p>我们将两个等比数列分别乘上 $p_1,p_2$ 得到数列 $\{\frac{1}{\sqrt5},\frac{1}{\sqrt5}\phi,\frac{1}{\sqrt5}\phi^2,…\}$ 和数列 $\{\frac{1}{\sqrt5},\frac{1}{\sqrt5}(1-\phi),\frac{1}{\sqrt5}(1-\phi)^2,…\}$ ，把两个数列加起来，便是斐波那契数列。</p><p>哦~我这就是特征根法的工作原理。对于一个 $k$ 阶递推式的 $k$ 个不同的特征根，我们可以得到 $k$ 个满足递推式的等比数列，将它们加（待）加（定）减（系）减（数）就能组合出原数列。</p><p>那么是不是 $k$ 个公比不同的等比数列就一定可以组合的出来原数列呢？这是一个关于<em>线性无关</em>的问题，我们下一章再说。结论是，一定能。</p><p>这个证明唯一美中不足的是，它显然是知道结果反过来证明过程的。如果没有上文的介绍，也许根本不能理解这个证明。就算已经熟悉特征根法了，也会觉得这个证明在攀附结果。</p><h2 id="重根的情况-1"><a href="#重根的情况-1" class="headerlink" title="重根的情况"></a>重根的情况</h2><p>麻烦的是，不是什么时候都能找到 $k$ 个<strong>不同</strong>的根，一旦有了重根，我们就找不到 $k$ 个公比不同的等比数列了。这使得我们待定的系数不到 $k$ 个，而我们又有 $k$ 个方程，大概率我们是解不出来的。</p><p>这就要求我们对于 $m$ 重根 $x$ ，我们除了找等比数列 $a_n=x^n$ ，还要找另外 $m-1$ 个数列，他们求通项都十分方便，而且他们之间不能加加减减就得到 。</p><p>直接证明并不方便，因为其后面蕴含着一些更为深刻的道理，我们将在下一章中知道。这里给出一个并不是十分漂亮的证明，但是不涉及到线性代数，高中知识足以应付，故放在这里仅供参考。</p><p>这需要一些高中的导数知识，有一些显而易见的性质。对于多项式 $f(\lambda)$ ,如果它在 $x$ 处有 $m$ 重根。那么它的导数 $f’(\lambda)$ 在 $x$ 处有 $m-1$ 重根，它的二阶导数 $f’’(\lambda)$ 在 $x$ 处有 $m-2$ 重根。简言之就是函数 $f(\lambda)$ 本身、一阶导数、二阶导数、…、$m-1$ 阶导数都在 $x$ 处有零点。即 <center>$f(x)=f'(x)=f''(x)=\cdots=f^{(m-1)}(x)=0$ </center></p><p>我们先来看一阶导数 $f’(\lambda)$ 。</p><center>$f(\lambda)=\lambda^k-c_1 \lambda^{k-1} -c_2 \lambda^{k-2} - \cdots - c_{k-1} \lambda -c_k$ </center><center>$f'(\lambda)=k\lambda^{k-1}-c_1 (k-1)\lambda^{k-2} -c_2 (k-2)\lambda^{k-3} - \cdots - c_{k-1} \times 1 -c_k \times 0$ </center><p>由 $f’(x)=0$ 可以得到：</p><center>$kx^{k-1}-c_1 (k-1)x^{k-2} -c_2 (k-2)x^{k-3} - \cdots - c_{k-1} \times 1 -c_k \times 0 = 0$ </center><center>$kx^k-c_1 (k-1)x^{k-1} -c_2 (k-2)x^{k-2} - \cdots - c_{k-1} x -c_k \times 0x^0 =0$ </center><center>$kx^k=c_1 (k-1)x^{k-1} +c_2 (k-2)x^{k-2} + \cdots + c_{k-1} x + c_k \times 0x^0$ </center><p>这个等式告诉我们，如果我们给数列 $\{a_n\}$ 赋初值 $a_i=ix^i,0 \leq i &lt; n$ ,根据递推式我们可以推出 $a_k=kx^k$ 。这是归纳的基石。接下来我们只需要归纳证明这个数列的通项确实是 $a_n=nx^n$ 就行了。这相当容易（就留作思考题吧）。</p><p>值得一提的是，如果我们考虑二阶导数 $f’’(x)=0$ ，我们直接得到的数列是 $a_n=n(n-1)x^n$ ，不过我们可以把这个数列加上 $b_n=nx^n$ ，这样就变成我们想要的 $a_n=n^2x^n$ 。更高阶的导数也要这么操作。如何使用 $n,n(n-1),n(n-1)(n-2),…,n(n-1)..(n-m+1)$ 的线性组合表示出 $n^m$， 这是个经典的组合问题，他们前面的系数被称为第二类斯特林数，具体可以看我另外一篇文章 《<a href="https://rabbitlb.github.io/2018/08/06/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0" target="_blank" rel="noopener">反演魔术——二项式反演</a>》 。</p><h1 id="真正的证明——矩阵"><a href="#真正的证明——矩阵" class="headerlink" title="真正的证明——矩阵"></a>真正的证明——矩阵</h1><p>在这一章中，我们将再提升一个层次看问题——矩阵的角度看我们刚才都做了什么，并且为什么刚才做的相当理所当然，而不是为了凑出结果而证明的。</p><h2 id="转移矩阵"><a href="#转移矩阵" class="headerlink" title="转移矩阵"></a>转移矩阵</h2><p>对于一个 $k$ 次的线性递推: </p><center>$ h_n = a_1 h_{n-1} + a_2 h_{n-2} + ... + a_k h_{n-k} , \forall\ n \in \mathbb{N}\ ,\ n > k $ </center><p>我们构造转移矩阵 </p><center>$ A = \begin{bmatrix} a_1 & a_2 & \cdots & a_{k-2} & a_{k-1} & a_k\\ 1 & 0 & \cdots & 0 & 0 & 0\\ 0 & 1 & \cdots & 0 & 0 & 0\\ \vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\ 0 & 0 & \cdots & 1 & 0 & 0\\ 0 & 0 & \cdots & 0 & 1 & 0 \end{bmatrix}_{k \times k}$ </center><p>和初始向量 </p><center> $x = \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix}_{k \times 1}$ </center><p>易见</p><center> $Ax = \begin{bmatrix} a_1 & a_2 & \cdots & a_{k-2} & a_{k-1} & a_k\\ 1 & 0 & \cdots & 0 & 0 & 0\\ 0 & 1 & \cdots & 0 & 0 & 0\\ \vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\ 0 & 0 & \cdots & 1 & 0 & 0\\ 0 & 0 & \cdots & 0 & 1 & 0 \end{bmatrix} \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix} = \begin{bmatrix} h_k \\ h_{k-1} \\ \vdots \\ h_3 \\ h_2 \\ h_1 \end{bmatrix} $ </center><p>显然这样可以顺次推下去，于是我们只要得到 $A^nx$ 就可以得到 $ h_n $ </p><h2 id="无重根的情况——矩阵对角化"><a href="#无重根的情况——矩阵对角化" class="headerlink" title="无重根的情况——矩阵对角化"></a>无重根的情况——矩阵对角化</h2><p>巨坑待填。。。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>都写得很好啊我能怎么办。</p><p><a href="http://www.matrix67.com/blog/archives/6784" target="_blank" rel="noopener">捡石子游戏、 Wythoff 数表和一切的 Fibonacci 数列</a>@matrix67<br><a href="https://www.zhihu.com/question/51662733/answer/126920544" target="_blank" rel="noopener">怎么用特征根法和不动点法求数列的通项公式? - 灵剑的回答 - 知乎</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特征根法是解决常系数齐次线性递推通项问题的通用做法。它十分普及，因为它简单好记。本文先简单介绍特征根法，然后给出几个证明。&lt;/p&gt;
&lt;h1 id=&quot;齐次线性递推&quot;&gt;&lt;a href=&quot;#齐次线性递推&quot; class=&quot;headerlink&quot; title=&quot;齐次线性递推&quot;&gt;&lt;/a&gt;齐次线性递推&lt;/h1&gt;&lt;p&gt;我们先来看一下齐次线性递推的概念。我们定义 $k$ 阶的齐次线性递推应该长这个样子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对任意 $n \in \mathbb{N}$，有 $a_{n+k} = c_1 a_{n+k-1} + c_2 a_{n+k-2} + \cdots + c_k a_n$ ，其中 $c_1 , c_2 , \cdots , c_k \in \mathbb{R}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了顺利推出每一项，这个递推还应该给出 $k$ 个初值 $a_0,a_1,a_2,\cdots,a_{k-1}$ 。 &lt;/p&gt;
&lt;p&gt;对了，在本文中，若未特别提及线性递推均为 $k$ 阶齐次线性递推。&lt;/p&gt;
&lt;h1 id=&quot;特征根法&quot;&gt;&lt;a href=&quot;#特征根法&quot; class=&quot;headerlink&quot; title=&quot;特征根法&quot;&gt;&lt;/a&gt;特征根法&lt;/h1&gt;&lt;p&gt;对于上面那个递推式，我们定义它的&lt;em&gt;特征方程&lt;/em&gt;为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\lambda^k=c_1 \lambda^{k-1} +c_2 \lambda^{k-2} + \cdots + c_{k-1} \lambda +c_k$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个方程有 $k$ 个根 $\lambda_1,\lambda_2,…,\lambda_k$ ，它们也许有些不是实数但没有关系。那么我们宣称数列 $\{a_n\}$ 的通项为&lt;/p&gt;
&lt;center&gt;$a_n=p_1\lambda_1^n+p_2\lambda_2^n+\cdots+p_k\lambda_k^n$ &lt;/center&gt;

&lt;p&gt;其中 $p_1,p_2,…,p_k$ 是待定的系数，通过把初值 $n=0,1,2,…,k-1$ 带入后，可以解出 $p_1,p_2,…,p_k$ 。&lt;/p&gt;
&lt;h2 id=&quot;重根的情况&quot;&gt;&lt;a href=&quot;#重根的情况&quot; class=&quot;headerlink&quot; title=&quot;重根的情况&quot;&gt;&lt;/a&gt;重根的情况&lt;/h2&gt;&lt;p&gt;重根的情况相对复杂。打个比方，假设 $\lambda_1=\lambda_2=\lambda_3$ 的话。我们只需要把原来设的通项中的 $p_1\lambda_1^n+p_2\lambda_2^n+p_3\lambda_3^n$ 改为 $(p_1n^2+p_2n+p_3)\lambda_1^n$ 就好了。具体来说就是，如果某个根有 $m$ 个重根，就设一个 $m-1$ 次的多项式乘上这个根的 $n$ 次方，不明白的可以再看看上面的例子。&lt;/p&gt;
&lt;h2 id=&quot;举个例子————斐波那契数列&quot;&gt;&lt;a href=&quot;#举个例子————斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;举个例子————斐波那契数列&quot;&gt;&lt;/a&gt;举个例子————斐波那契数列&lt;/h2&gt;&lt;p&gt;斐波那契数列 $\{f_n\}$ 满足递推关系 $f_{n+2}=f_{n+1}+f_n$ ，且有初值 $f_0=0$,$f_1=1$ 。求它的通项当然可以通过构造等比数列或者求生成函数的方法来求，但在这里，特征根法是最简单的一种。&lt;br&gt;
    
    </summary>
    
      <category term="Maths" scheme="http://blog.rabbit-lb.cn/categories/Maths/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="线性代数" scheme="http://blog.rabbit-lb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>特征多项式简化多变量常系数线性递推</title>
    <link href="http://blog.rabbit-lb.cn/2018/08/09/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%AE%80%E5%8C%96%E5%A4%9A%E5%8F%98%E9%87%8F%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    <id>http://blog.rabbit-lb.cn/2018/08/09/特征多项式简化多变量常系数线性递推/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2018-08-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>化零多项式，例如特征多项式可以优化单变量的线性递推（详见博客《<a href="http://blog.rabbit-lb.cn/2018/07/27/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/">特征多项式优化线性递推</a>》），我们来考虑多变量线性递推。我们先来看几个问题，从中体会一下怎么利用化零多项式优化线性递推。</p><h1 id="好集个数"><a href="#好集个数" class="headerlink" title="好集个数"></a>好集个数</h1><p>如果一个集合的全体元素之和为 $3$ 的倍数，我们则称之为<strong>好集</strong>（空集元素之和为 $0$ ）。<br>那么，在集合 $\{1,2,3,…,3n\}$ 的所有子集中，有多少个<strong>好集</strong>？</p><p>这道题(个人认为的)最漂亮的做法并不是利用线性递推，我将这个做法补充在文章结尾。</p><p>我们暴力一点，假设 $a_n$ 表示和为 $3$ 的倍数的集合个数，$b_n$ 表示和除 $3$ 余 $1$ 的集合个数，$c_n$ 表示和除 $3$ 余 $2$ 的集合个数,于是我们有：</p><center> $\begin{bmatrix}4 & 2 & 2\\2 & 4 & 2\\2 & 2 & 4\end{bmatrix}$ $\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}$ $=\begin{bmatrix} a_{n+1} \\ b_{n+1} \\ c_{n+1} \end{bmatrix}$ </center><p>我们记：</p><center> $A=\begin{bmatrix}4 & 2 & 2\\2 & 4 & 2\\2 & 2 & 4\end{bmatrix}$ </center><p>考虑 $A$ 的特征多项式 $f(\lambda)=-\lambda^3+12\lambda^2-36\lambda+32$。<br>根据 Caylay-Camilton 定理我们有 $f(A)=-A^3+12A^2-36A+32I=0$,于是我们得到：</p><center>$(-A^3+12A^2-36A+32I)\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ </center><center>$A^3\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}-12A^2\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}+36A\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}-32\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ </center><center>$\begin{bmatrix} a_{n+3} \\ b_{n+3} \\ c_{n+3} \end{bmatrix}-12\begin{bmatrix} a_{n+2} \\ b_{n+2} \\ c_{n+2} \end{bmatrix}+36\begin{bmatrix} a_{n+1} \\ b_{n+1} \\ c_{n+1} \end{bmatrix}-32\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ </center><center>$\begin{bmatrix} a_{n+3}-12a_{n+2}+36a_{n+1}-32a_n \\ b_{n+3}-12b_{n+2}+36b_{n+1}-32b_n \\  c_{n+3}-12c_{n+2}+36c_{n+1}-32c_n \end{bmatrix}=0$ </center><p>故：$a_{n+3}-12a_{n+2}+36a_{n+1}-32a_n =0 \Leftrightarrow a_{n+3}=12a_{n+2}-36a_{n+1}+32a_n$。</p><p>我们就根据转移矩阵得到递推式了，之后我们就可以使用特征方程法或者生成函数法求通项了，这都是后话。<br>值得注意的是，如果使用特征方程法，其特征方程就是 $f(\lambda)=0$（想想为什么） 。<br><a id="more"></a></p><h1 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h1><p>我们发现这个方法适用于任何有较多变量的线性递推（其实任何能用转移矩阵转移的都可以），我们只需要求出转移矩阵的特征多项式。那么对于线性递推中的每一个变量，其递推式系数就是特征多项式前的系数。</p><p>有趣的是，每一个不同的变量拥有同样的递推式和特征方程。</p><h1 id="好集个数问题的一个非递推解法"><a href="#好集个数问题的一个非递推解法" class="headerlink" title="好集个数问题的一个非递推解法"></a>好集个数问题的一个非递推解法</h1><p>考虑函数 $f(x)=(x+1)(x^2+1)(x^3+1)…(x^{3n}+1)$ 的展开式。我们记：</p><center>$f(x)=a_0x^0+a_1x^1+a_2x^2+...$ </center>考虑乘法分配律的过程，我们可以知道 $a_t$ 表示元素之和为 $t$ 的子集个数。于是我们设：<center>$p=a_0+a_3+a_6+...$ $q=a_1+a_4+a_7+...$ $r=a_2+a_5+a_8+...$ </center>于是 $p$ 即为答案。我们记三次单位根为 $\omega=\frac{-1+\sqrt{3}i}{2}$ 。于是有 $\omega^3=1$ 以及 $\omega^2+\omega+1=0$我们考虑把 $1,\omega,\omega^2$ 带入 $f(x)$ 可以得到：<center>$f(1)=a_0+a_1+a_2+...=p+q+r=(1+1)(1+1)...(1+1)=2^{3n}$ $f(\omega)=a_0+a_1\omega+a_2\omega^2+a_3+a_4\omega+a_5\omega^2+...=p+\omega q+\omega^2r=((1+1)(\omega+1)(\omega^2+1))^n=2^n$ $f(\omega^2)=a_0+a_1\omega^2+a_2\omega+a_3+a_4\omega^2+a_5\omega+...=p+\omega^2 q+\omega r=((1+1)(\omega^2+1)(\omega+1))^n=2^n$ </center><p>三式相加可得 $3p=2^{3n}+2^{n+1}$ ,答案即 $p=\frac{2^{3n}+2^{n+1}}{3}$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;化零多项式，例如特征多项式可以优化单变量的线性递推（详见博客《&lt;a href=&quot;http://blog.rabbit-lb.cn/2018/07/27/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/&quot;&gt;特征多项式优化线性递推&lt;/a&gt;》），我们来考虑多变量线性递推。我们先来看几个问题，从中体会一下怎么利用化零多项式优化线性递推。&lt;/p&gt;
&lt;h1 id=&quot;好集个数&quot;&gt;&lt;a href=&quot;#好集个数&quot; class=&quot;headerlink&quot; title=&quot;好集个数&quot;&gt;&lt;/a&gt;好集个数&lt;/h1&gt;&lt;p&gt;如果一个集合的全体元素之和为 $3$ 的倍数，我们则称之为&lt;strong&gt;好集&lt;/strong&gt;（空集元素之和为 $0$ ）。&lt;br&gt;那么，在集合 $\{1,2,3,…,3n\}$ 的所有子集中，有多少个&lt;strong&gt;好集&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;这道题(个人认为的)最漂亮的做法并不是利用线性递推，我将这个做法补充在文章结尾。&lt;/p&gt;
&lt;p&gt;我们暴力一点，假设 $a_n$ 表示和为 $3$ 的倍数的集合个数，$b_n$ 表示和除 $3$ 余 $1$ 的集合个数，$c_n$ 表示和除 $3$ 余 $2$ 的集合个数,于是我们有：&lt;/p&gt;
&lt;center&gt; $\begin{bmatrix}4 &amp; 2 &amp; 2\\2 &amp; 4 &amp; 2\\2 &amp; 2 &amp; 4\end{bmatrix}$ $\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}$ $=\begin{bmatrix} a_{n+1} \\ b_{n+1} \\ c_{n+1} \end{bmatrix}$ &lt;/center&gt;

&lt;p&gt;我们记：&lt;/p&gt;
&lt;center&gt; $A=\begin{bmatrix}4 &amp; 2 &amp; 2\\2 &amp; 4 &amp; 2\\2 &amp; 2 &amp; 4\end{bmatrix}$ &lt;/center&gt;

&lt;p&gt;考虑 $A$ 的特征多项式 $f(\lambda)=-\lambda^3+12\lambda^2-36\lambda+32$。&lt;br&gt;根据 Caylay-Camilton 定理我们有 $f(A)=-A^3+12A^2-36A+32I=0$,于是我们得到：&lt;/p&gt;
&lt;center&gt;$(-A^3+12A^2-36A+32I)\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ &lt;/center&gt;
&lt;center&gt;$A^3\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}-12A^2\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}+36A\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}-32\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ &lt;/center&gt;
&lt;center&gt;$\begin{bmatrix} a_{n+3} \\ b_{n+3} \\ c_{n+3} \end{bmatrix}-12\begin{bmatrix} a_{n+2} \\ b_{n+2} \\ c_{n+2} \end{bmatrix}+36\begin{bmatrix} a_{n+1} \\ b_{n+1} \\ c_{n+1} \end{bmatrix}-32\begin{bmatrix} a_n \\ b_n \\ c_n \end{bmatrix}=0$ &lt;/center&gt;
&lt;center&gt;$\begin{bmatrix} a_{n+3}-12a_{n+2}+36a_{n+1}-32a_n \\ b_{n+3}-12b_{n+2}+36b_{n+1}-32b_n \\  c_{n+3}-12c_{n+2}+36c_{n+1}-32c_n \end{bmatrix}=0$ &lt;/center&gt;

&lt;p&gt;故：$a_{n+3}-12a_{n+2}+36a_{n+1}-32a_n =0 \Leftrightarrow a_{n+3}=12a_{n+2}-36a_{n+1}+32a_n$。&lt;/p&gt;
&lt;p&gt;我们就根据转移矩阵得到递推式了，之后我们就可以使用特征方程法或者生成函数法求通项了，这都是后话。&lt;br&gt;值得注意的是，如果使用特征方程法，其特征方程就是 $f(\lambda)=0$（想想为什么） 。&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性代数" scheme="http://blog.rabbit-lb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="数学随笔" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>调和级数相关——质数的倒数和增长速度为O(ln ln n)</title>
    <link href="http://blog.rabbit-lb.cn/2018/08/08/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0%E7%9B%B8%E5%85%B3%E2%80%94%E2%80%94%E8%B4%A8%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E5%92%8C%E5%A2%9E%E9%95%BF%E9%80%9F%E5%BA%A6%E4%B8%BAO(n-log-log-n)/"/>
    <id>http://blog.rabbit-lb.cn/2018/08/08/调和级数相关——质数的倒数和增长速度为O(n-log-log-n)/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来分析调和级数和质数的倒数和的增长速度，最后聊一聊关于调和级数的有趣的事情。</p><h1 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h1><p>我们常用<em>级数</em>来表示一个数列的前缀和。调和级数就是自然数倒数序列 $\{\frac{1}{n}\}$ 的和，其表达式为:</p><center>$\sum_{i=1}^{\infty}\frac{1}{n}=1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+...$ </center><p>这个和发散，但发散地极慢。举例来说，调和序列前 $10^{43}$ 项的和还不足 $100$。人们甚至一度认为这个数列收敛。欧拉精准地估计了这个和，并标明这个和的增长速度与自然对数的增长速度相同。具体来说：</p><center>$\sum_{i=1}^{n} \frac{1}{i} = \ln n + \gamma + O(1/n)$ </center><p>其中，误差项 $O(\frac{1}{n})$ 在 $n$ 增大时趋近于零，可以忽略不计。</p><p>欧拉的证明附于文尾。</p><h1 id="质数的倒数和"><a href="#质数的倒数和" class="headerlink" title="质数的倒数和"></a>质数的倒数和</h1><p>事实上，质数的倒数和的增长速度是 $O(\ln \ln n)$ 下面给出简单证明：<br><a id="more"></a><br>我们先来观察这样一个等式:</p><center>$\sum_{i=1}^{\infty}\frac{1}{n}=(1+\frac{1}{2}+\frac{1}{2^2}+\frac{1}{2^3}+...)(1+\frac{1}{3}+\frac{1}{3^2}+\frac{1}{3^3}+...)(1+\frac{1}{5}+\frac{1}{5^2}+\frac{1}{5^3}+...)$ </center><center>$=\frac{1}{1-\frac{1}{2}}\times\frac{1}{1-\frac{1}{3}}\times\frac{1}{1-\frac{1}{5}}\times...$ </center><center>$=\prod_{p_i \in \mathbb{P}} \frac{1}{1-\frac{1}{p_i}}$ </center><p>这是由于算术基本定理，即每一个 $n$ 只有唯一一种质因数分解。(之后的每一个等式都应该使用大O表示，但这里为了等式的完整美观暂时忽略大O表示）故：</p><center>$\ln(\sum_{i=1}^{n} \frac{1}{i}) = \ln(\prod_{p_i \leq n} \frac{1}{1-\frac{1}{p_i}})$ </center><center>$= \sum_{p_i \leq n}\ln( \frac{1}{1-\frac{1}{p_i}})$ </center><center>$= -\sum_{p_i \leq n}\ln( 1-\frac{1}{p_i})$ </center><center>$= \sum_{p_i \leq n} \frac{1}{p_i} + O(\frac{1}{p_i^2})$ </center><p>最后一步考虑 $\ln(1-x)$ 的泰勒展开:</p><center>$\ln (1-x) = x + \frac{x^2}{2} + \frac{x^3}{3} + O(x^4)$ </center><p>于是我们得到(大O表示又回来了）：</p><center>$O(\sum_{p_i \leq n} \frac{1}{p_i}) = O(\ln(\sum_{i=1}^{n} \frac{1}{i})) =O(\ln \ln n)$ </center><h1 id="埃拉托斯特尼筛法的时间复杂度"><a href="#埃拉托斯特尼筛法的时间复杂度" class="headerlink" title="埃拉托斯特尼筛法的时间复杂度"></a>埃拉托斯特尼筛法的时间复杂度</h1><p>考虑埃拉托斯特尼筛法的过程，可以得到其复杂度为：</p><center> $\sum_{p_i \in \mathbb{P},p_i \leq n} \frac{n}{p_i} = n \sum_{p_i \leq n} \frac{1}{p_i} = O(n \ln \ln n)$ </center><h1 id="调和级数增长速度————欧拉的证明"><a href="#调和级数增长速度————欧拉的证明" class="headerlink" title="调和级数增长速度————欧拉的证明"></a>调和级数增长速度————欧拉的证明</h1><p>我们首先观察 $\ln(1+\frac{1}{x})$ 的泰勒展开：</p><center>$\ln(1+\frac{1}{x})=\frac{1}{x}-\frac{1}{2x^2}+\frac{1}{3x^3}-\frac{1}{4x^4}+...$ </center><center>$\frac{1}{x}=\ln(\frac{x+1}{x})+\frac{1}{2x^2}-\frac{1}{3x^3}+\frac{1}{4x^4}-...$ </center><p>直接累加得到：</p><center>$\sum_{i=1}^{n} \frac{1}{i}=\sum_{i=1}^{n} \ln(\frac{i+1}{i}) + \frac{1}{2} \sum_{i=1}^{n} \frac{1}{x^2}-\frac{1}{3} \sum_{i=1}^{n} \frac{1}{x^3}+\frac{1}{4} \sum_{i=1}^{n} \frac{1}{x^4}-...$ </center><center>$= \ln(n+1) + \gamma + O(\frac{1}{n})$ </center><p>其中 $\gamma$ 是一个常数（欧拉常数）。这是因为后面很多项是自然数平方、立方等等的倒数和，之前欧拉证明过他们都将收敛于一个常数（严格来说欧拉只证明了自然数偶数次的倒数和收敛于一个固定的常数，详细请见我的博客《<a href="http://blog.rabbit-lb.cn/2018/06/26/%E5%86%8D%E6%8E%A2%CF%80%5E2%C3%B76/">再探π^2/6</a>》）</p><h1 id="交错的调和级数的和"><a href="#交错的调和级数的和" class="headerlink" title="交错的调和级数的和"></a>交错的调和级数的和</h1><p>考虑 $\ln(1+x)$ 的泰勒展开:</p><center>$\ln (1+x) = x - \frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4}+...$ </center><p>带入 $x=1$ 可得：</p><center>$1 - \frac{1}{2} + \frac{1}{3} - \frac{1}{4}+... = \ln 2$ </center><p>它居然收敛！</p><h1 id="交错的奇自然数倒数和"><a href="#交错的奇自然数倒数和" class="headerlink" title="交错的奇自然数倒数和"></a>交错的奇自然数倒数和</h1><p>考虑反正切函数 $\arctan x$ 的泰勒展开:</p><center>$\arctan x = x - \frac{x^3}{3} + \frac{x^5}{5} - \frac{x^7}{7}+...$ </center><p>带入 $x=1$ 可得：</p><center>$1 - \frac{1}{3} + \frac{1}{5} - \frac{1}{7}+... = \frac{\pi}{4}$ </center><p>这个居然收敛于 $\frac{\pi}{4}$ !<br>顺便一提，这个公式被称为 $\pi$ 的莱布尼茨公式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来分析调和级数和质数的倒数和的增长速度，最后聊一聊关于调和级数的有趣的事情。&lt;/p&gt;
&lt;h1 id=&quot;调和级数&quot;&gt;&lt;a href=&quot;#调和级数&quot; class=&quot;headerlink&quot; title=&quot;调和级数&quot;&gt;&lt;/a&gt;调和级数&lt;/h1&gt;&lt;p&gt;我们常用&lt;em&gt;级数&lt;/em&gt;来表示一个数列的前缀和。调和级数就是自然数倒数序列 $\{\frac{1}{n}\}$ 的和，其表达式为:&lt;/p&gt;
&lt;center&gt;$\sum_{i=1}^{\infty}\frac{1}{n}=1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+...$ &lt;/center&gt;

&lt;p&gt;这个和发散，但发散地极慢。举例来说，调和序列前 $10^{43}$ 项的和还不足 $100$。人们甚至一度认为这个数列收敛。欧拉精准地估计了这个和，并标明这个和的增长速度与自然对数的增长速度相同。具体来说：&lt;/p&gt;
&lt;center&gt;$\sum_{i=1}^{n} \frac{1}{i} = \ln n + \gamma + O(1/n)$ &lt;/center&gt;

&lt;p&gt;其中，误差项 $O(\frac{1}{n})$ 在 $n$ 增大时趋近于零，可以忽略不计。&lt;/p&gt;
&lt;p&gt;欧拉的证明附于文尾。&lt;/p&gt;
&lt;h1 id=&quot;质数的倒数和&quot;&gt;&lt;a href=&quot;#质数的倒数和&quot; class=&quot;headerlink&quot; title=&quot;质数的倒数和&quot;&gt;&lt;/a&gt;质数的倒数和&lt;/h1&gt;&lt;p&gt;事实上，质数的倒数和的增长速度是 $O(\ln \ln n)$ 下面给出简单证明：&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>多项式线性插值算法</title>
    <link href="http://blog.rabbit-lb.cn/2018/08/07/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"/>
    <id>http://blog.rabbit-lb.cn/2018/08/07/多项式的线性插值/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2018-08-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家去看杜瑜皓@《<a href="/uploads/多项式及求和_By_浙江省镇海中学_杜瑜皓_OI-WC2013.pdf">多项式及求和</a>》</p><p>多项式线性插值算法讲的是：</p><blockquote><p>已知一个 $k$ 次多项式 $F(x)$ 在整点 $0,1,2,3,4,5,…,k$ 处的值为 $F(0),F(1),F(2),…,F(k)$<br>我们能够在 $O(k)$ 的时间内求出 $F(n)$ 或者在 $O(k \log k）$ 的时间内求出原多项式$F(x)$ </p></blockquote><h1 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h1><p>欢迎大家去看我的博客《<a href="http://blog.rabbit-lb.cn/2018/08/06/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/">二项式反演</a>》啊orz</p><p>简单来说就是我们发现如果数列 $\{f_n\}$ 和 $\{g_n\}$ 满足:</p><center>$g_n=\sum_{i=0}^n C_n^i f_i$ </center><p>则：</p><center>$f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ </center><h1 id="牛顿级数"><a href="#牛顿级数" class="headerlink" title="牛顿级数"></a>牛顿级数</h1><p>我们发现 $C_x^0,C_x^1,C_x^2,…,C_x^k$ 次数两两不同，他们线性无关，于是我们设：</p><center>$F(x)=\sum_{i=0}^k C_x^i p_i$ </center><p>由二项式反演就可以得到：</p><center>$p_n=\sum_{i=0}^n (-1)^{n-i}C_n^iF(i)$ </center><center>$\frac{p_n}{n!}=\sum_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}\frac{F(i)}{i!}$ </center><p>显然我们可以通过FFT在 $O(k \log k)$ 时间内算出各项系数 $p_i$ 。<br><a id="more"></a></p><h1 id="FFT？"><a href="#FFT？" class="headerlink" title="FFT？"></a>FFT？</h1><p>我们真的需要使用FFT来求 $F(n)$ 吗？</p><p>对于 $x &gt; k$ 的 $F(x)$，有：</p><center>$F(x)=\sum_{i=0}^k C_x^i p_i$ $=\sum_{i=0}^k C_x^i \sum_{j=0}^i (-1)^{i-j}C_i^jF(j)$ </center><center>$=\sum_{i=0}^k \sum_{j=0}^i F(j) (-1)^{i-j}C_x^iC_i^j$ </center><center>$=\sum_{j=0}^k F(j) \sum_{i=j}^k  (-1)^{i-j}C_x^jC_{n-j}^{i-j}$ </center><center>$=\sum_{j=0}^k C_x^j F(j) \sum_{i=j}^k(-1)^{i-j}C_{n-j}^{i-j}$ </center><center>$=\sum_{j=0}^k C_x^j F(j) (-1)^{k-j}C_{n-j-1}^{k-j}$ </center><center>$=\sum_{j=0}^k (-1)^{k-j} F(j) \frac{x!(x-j-1)!}{j!(x-j)!(k-j)!(x-k-1)!}$ </center><center>$=\sum_{j=0}^k (-1)^{k-j} F(j) \frac{x(x-1)(x-2)...(x-k)}{(x-j)j!(k-j)!}$ </center><p>这样我们就可以在知道 $F(0),F(1),…,F(k)$ 的情况下，在 $O(k)$ 时间内求出 $F(n)$。</p><h1 id="二项式反演？"><a href="#二项式反演？" class="headerlink" title="二项式反演？"></a>二项式反演？</h1><p>如果你会多项式插值的话就知道，这其实就是拉格朗日插值。</p><blockquote><p>拉格朗日插值法</p><blockquote><p>如果我们有 $F(x_1)=y_1,F(x_2)=y_2,…,F(x_n)=y_n$，则<strong>拉格朗日插值多项式</strong>等于<br>$F(x)=\sum_{i=1}^n y_i \prod_{j=1,j \neq i}^n \frac{x-x_j}{x_i-x_j}$</p></blockquote></blockquote><p>我们尝试带入 $0,1,2,…,k$ 和 $F(0),F(1),…,F(k)$ :</p><center>$F(x)=\sum_{i=0}^k F(i) \prod_{j=0,j \neq i}^k \frac{x-j}{i-j}$ </center><center>$=\sum_{i=0}^k F(i) \frac{x(x-1)(x-2)...(x-k)}{(x-i)(i-0)(i-1)...\times 1 \times (-1) \times (-2) \times ...\times (i-k)}$ </center><center>$=\sum_{i=0}^k F(i) \frac{x(x-1)(x-2)...(x-k)}{(x-i) i! (-1)^{k-i}(k-i)!}$ </center><center>$=\sum_{i=0}^k (-1)^{k-i} F(i) \frac{x(x-1)(x-2)...(x-k)}{(x-i) i! (k-i)!}$ </center><p>大功告成！</p><h1 id="例-自然数幂和"><a href="#例-自然数幂和" class="headerlink" title="例: 自然数幂和"></a>例: 自然数幂和</h1><p>已知 $k \leq 2 \times 10^5,n \leq 10^{10000},p \leq 10^{18}$ 且 $p$ 为质数。<br>求 $\sum_{i=0}^n i^k$ 对 $p$ 取模的结果。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们记 $F(x)=\sum_{i=0}^x i^k,x \in \mathbb{N}$ 。首先我们需要知道 $F(x)$ 是一个 $k+1$ 次多项式。只需求出$F(0),F(1),…,F(k+1)$ 就可以使用上面讲的线性插值求出 $F(n)$ 啦orz</p><p>求$F(0),F(1),..,F(k+1)$ 的话注意到 $i^k$ 是完全积性函数，可以用欧拉筛法在线性时间内求出 $0^k,1^k,…,(k+1)^k$，问题完美解决。</p><p>对了，你可以尝试挑战一下 <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4126" target="_blank" rel="noopener">BZOJ-4126. 国王奇遇记加强版之再加强版</a> 。体验一下线性插值带来的快感。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家去看杜瑜皓@《&lt;a href=&quot;/uploads/多项式及求和_By_浙江省镇海中学_杜瑜皓_OI-WC2013.pdf&quot;&gt;多项式及求和&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;多项式线性插值算法讲的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已知一个 $k$ 次多项式 $F(x)$ 在整点 $0,1,2,3,4,5,…,k$ 处的值为 $F(0),F(1),F(2),…,F(k)$&lt;br&gt;我们能够在 $O(k)$ 的时间内求出 $F(n)$ 或者在 $O(k \log k）$ 的时间内求出原多项式$F(x)$ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;二项式反演&quot;&gt;&lt;a href=&quot;#二项式反演&quot; class=&quot;headerlink&quot; title=&quot;二项式反演&quot;&gt;&lt;/a&gt;二项式反演&lt;/h1&gt;&lt;p&gt;欢迎大家去看我的博客《&lt;a href=&quot;http://blog.rabbit-lb.cn/2018/08/06/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/&quot;&gt;二项式反演&lt;/a&gt;》啊orz&lt;/p&gt;
&lt;p&gt;简单来说就是我们发现如果数列 $\{f_n\}$ 和 $\{g_n\}$ 满足:&lt;/p&gt;
&lt;center&gt;$g_n=\sum_{i=0}^n C_n^i f_i$ &lt;/center&gt;

&lt;p&gt;则：&lt;/p&gt;
&lt;center&gt;$f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ &lt;/center&gt;

&lt;h1 id=&quot;牛顿级数&quot;&gt;&lt;a href=&quot;#牛顿级数&quot; class=&quot;headerlink&quot; title=&quot;牛顿级数&quot;&gt;&lt;/a&gt;牛顿级数&lt;/h1&gt;&lt;p&gt;我们发现 $C_x^0,C_x^1,C_x^2,…,C_x^k$ 次数两两不同，他们线性无关，于是我们设：&lt;/p&gt;
&lt;center&gt;$F(x)=\sum_{i=0}^k C_x^i p_i$ &lt;/center&gt;

&lt;p&gt;由二项式反演就可以得到：&lt;/p&gt;
&lt;center&gt;$p_n=\sum_{i=0}^n (-1)^{n-i}C_n^iF(i)$ &lt;/center&gt;
&lt;center&gt;$\frac{p_n}{n!}=\sum_{i=0}^n\frac{(-1)^{n-i}}{(n-i)!}\frac{F(i)}{i!}$ &lt;/center&gt;

&lt;p&gt;显然我们可以通过FFT在 $O(k \log k)$ 时间内算出各项系数 $p_i$ 。&lt;br&gt;
    
    </summary>
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="多项式理论" scheme="http://blog.rabbit-lb.cn/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>反演魔术————二项式反演</title>
    <link href="http://blog.rabbit-lb.cn/2018/08/06/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    <id>http://blog.rabbit-lb.cn/2018/08/06/二项式反演/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2018-08-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>演绎推理是我们在数学中经常遇到的一些方法。对于数列来说，通过原数列计算出新的数列叫作演绎，而通过计算出的数列反推出原数列则被称为反演。</p><p>形式化地，如果原数列为 $\{f_n\}$，新数列是 $\{g_n\}$ ，且满足 </p><center>$g_n=\sum_{i=0}^n a_{ni} f_i$ </center><p>反演就是我们希望通过 $\{g_n\}$ 得到 $\{f_n\}$ :</p><center>$f_n=\sum_{i=0}^n b_{ni} g_i$ </center><p>结合一下就是</p><center>$g_n=\sum_{i=0}^n a_{ni} f_i \Leftrightarrow f_n=\sum_{i=0}^n b_{ni} g_i$ </center><p>数列反演有许许多多种不同的类型，就例如莫比乌斯反演，二项式反演等等。其实，我们发现反演其实就是在解方程，一些方程组有算法上固定的、特殊的解，我们对于这些特殊的算法冠以具体的名字，就例如二项式反演。</p><h1 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h1><p>二项式反演讲的是:</p><blockquote> <center>$g_n=\sum_{i=0}^n (-1)^i C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^i C_n^i g_i$ </center></blockquote><p>这个式子高度对称，它还有一个等价形式是我们所常用的：</p><blockquote><center>$g_n=\sum_{i=0}^n C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ </center></blockquote><p>其实这里应该是双箭头，但是在这里右式是反演，左式则是演绎，故我们向右推出。先来证明这个反演公式，然后介绍它的应用。</p><a id="more"></a><h2 id="代数证明"><a href="#代数证明" class="headerlink" title="代数证明"></a>代数证明</h2><p>我们从右边开始，将 $g_n=\sum_{i=0}^n C_n^i f_i$ 带入:</p><center>$\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ $= \sum_{i=0}^n (-1)^{n-i} C_n^i \sum_{j=0}^i C_i^j f_j$ </center><center>$= \sum_{i=0}^n \sum_{j=0}^i (-1)^{n-i} C_n^i C_i^j f_j$ </center><p>我们尝试交换求和顺序。首先我们观察到:</p><center>$C_n^iC_i^j=\frac{n!}{i!(n-i)!}\frac{i!}{j!(i-j)!}=\frac{n!}{j!(n-j)!}\frac{(n-j)!}{(n-i)!(i-j)!}=C_n^jC_{n-j}^{n-i}$ </center><p>带入进去得到:</p><center>$\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ $= \sum_{i=0}^n \sum_{j=0}^i (-1)^{n-i} C_n^jC_{n-j}^{n-i} f_j$ </center><center>$= \sum_{j=0}^n \sum_{i=j}^n C_n^j f_j (-1)^{n-i}C_{n-j}^{n-i}$ </center><p>在这里我们交换了求和顺序，是因为我们发现两重 $\sum$ 所需要的 $(i,j)$ 依次是</p><p>$(0,0)$<br>$(1,0) (1,1)$<br>$(2,0) (2,1) (2,2)$<br>$(3,0) (3,1) (3,2) (3,3)$<br>$\ \ \ \vdots\ \ \ \ \ \ \ \ \vdots\ \ \ \ \ \ \ \ \vdots\ \ \ \ \ \ \ \ \vdots\ \ \ \ \ \ \ \ \ddots$<br>$(n,0) (n,1) (n,2) (n,3)\ \ \ \cdots\ \ \ (n,n)$</p><p>我们这是一行一行求得的，我们现在尝试一列一列求:</p><p>$(0,0) (1,0) (2,0) (3,0)\ \ \ \cdots\ \ \ (n,0)$<br>$(1,1) (2,1) (3,1)\ \ \ \cdots\ \ \ (n,1)$<br>$(2,2) (3,2)\ \ \ \cdots\ \ \ (n,2)$<br>$(3,3)\ \ \ \cdots\ \ \ (n,3)$<br>$\ \ \ \ \vdots $<br>$(n,n)$ </p><p>把 $C_n^jf_j$ 提取出来得到：</p><center>$\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ $= \sum_{j=0}^n C_n^j f_j \sum_{i=j}^n (-1)^{n-i}C_{n-j}^{n-i}$ </center><p>我们着眼于: $\sum_{i=j}^n (-1)^{n-i}C_{n-j}^{n-i} =\sum_{k=0}^{n-j} (-1)^kC_{n-j}^k$</p><ul><li>当 $n-j \neq 0$ 时，$\sum_{k=0}^{n-j} (-1)^kC_{n-j}^k=(1-1)^{n-j}=0$ </li><li>当 $n-j = 0$ 时，$j=n$ 且 $\sum_{k=0}^{n-j} (-1)^kC_{n-j}^k=(-1)^0C_0^0=1$</li></ul><p>所以只有当 $j=n$ 时 $\sum_{i=0}^n (-1)^{n-i} C_n^i g_i \neq 0$，于是</p><center>$\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ $= C_n^n f_n (-1)^{0}C_{0}^{0} = f_n$ </center><p>证毕。</p><h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>生成函数证法尤为简单。我们对原式展开后移项：</p><center>$g_n=\sum_{i=0}^n C_n^i f_i =\sum_{i=0}^n \frac{n!}{i!(n-i)!} f_i $ </center><center>$\Leftrightarrow \frac{g_n}{n!}=\sum_{i=0}^n \frac{1}{(n-i)!} \frac{f_i}{i!}$ </center><p>这是一个卷积形式，我们记 $\{f_n\}$ 的指数生成函数为 $F(x)$ ，记 $\{g_n\}$ 的指数生成函数为 $G(x)$</p><p>于是我们有 $G(x)=e^xF(x) \Leftrightarrow F(x)=e^{-x}G(x)$</p><p>考虑 $F(x)$ 的 $n$ 次方系数有:</p><center>$\frac{f_n}{n!}=\sum_{i=0}^n \frac{(-1)^{n-i}}{(n-i)!} \frac{g_i}{i!} \Leftrightarrow f_n=\sum_{i=0}^n (-1)^{n-i} \frac{n!}{i!(n-i)!} g_i $ </center><center>$\Leftrightarrow f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ </center><p>证毕。</p><h1 id="二项式反演的应用"><a href="#二项式反演的应用" class="headerlink" title="二项式反演的应用"></a>二项式反演的应用</h1><h2 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h2><p>错排问题又称伯努利错装信封问题。这个问题有很多不同的题面，下面是其中一种</p><blockquote><p>伯努利错装信封问题</p><blockquote><p>有一个粗心的邮差让 $n$ 封信从信封中掉了出来，但他并不知道每一封信对应着哪一个信封。不负责任的他随机地把信胡乱塞进信封里。问一共有多少种装信的方案使得信全部装进了不同的信封。</p></blockquote></blockquote><p>我们记错排数为 $\{D_n\}$，表示将 $n$ 封信全部装错的方案数。</p><p>我们考虑随便装，一共有 $n!$ 种方案。每种方案可能装错其中的 $0,1,2,…,n$ 封信。考虑装错 $i$ 封信的方案种数，应该是 $C_n^iD_i$, 表示先选出 $i$ 封信有 $C_n^i$ 种，然后装错它们有 $D_i$ 种，乘法原理得到一共 $C_n^iD_i$ 种。故：</p><center>$n!=\sum_{i=0}^n C_n^iD_i$ </center><p>利用二项式反演公式 $g_n=\sum_{i=0}^n C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ 可得:</p><center>$D_n=\sum_{i=0}^n (-1)^{n-i} C_n^i i!=\sum_{i=0}^n (-1)^{n-i}\frac{n!}{(n-i)!} $ </center><center>$=n!\sum_{i=0}^n \frac{(-1)^i}{i!}$ </center><p>这就是错排公式。</p><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><blockquote><p>将 $n$ 个不同的球放进 $m$ 个不同的盒子，保证盒子非空，求方案数。</p></blockquote><p>记 $n$ 个不同的球放进 $m$ 个不同的盒子里的方案总数为 $Q_n^m$。我们来尝试 $Q_n^m$。</p><p>如果将 $n$ 个球随便放进 $m$ 个箱子里而不考虑非空，则一共有 $m^n$ 种方案数。这些方案中，只可能 $0,1,2,…,m$ 个盒子非空。其中，$i$ 个盒子非空的方案数一共 $C_m^iQ_n^i$ ，这表示选出 $i$ 个非空的盒子有 $C_m^i$ 中，他们装 $n$ 个不同的球有 $Q_n^i$ 种。于是我们就有：</p><center>$m^n=\sum_{i=0}^mC_m^iQ_n^i$ </center> <p>利用二项式反演公式 $g_n=\sum_{i=0}^n C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ 可得:</p><center>$Q_n^m=\sum_{i=0}^m (-1)^{m-i} C_m^i i^n$ </center> <p>完美解决。</p><p>第二类斯特林数指的是 <strong>将 $n$ 个不同的球放进 $m$ 个无差别的盒子，保证盒子非空，求方案数。</strong></p><p>很明显，只需要把有差别的方案数 $Q_n^m$ 除以盒子的排列数 $m!$ 就是答案，即有第二类斯特林数 $S_n^m$ :</p><center>$S_n^m=\frac{1}{m!}\sum_{i=0}^m (-1)^{m-i} C_m^i i^n$ </center><p>值得一提的是，类比上面我们同样可以得到关于第二类斯特林数的等式:</p><center>$m^n=\sum_{i=0}^mP_m^iS_n^i$ </center><p>再看一眼:</p><center>$m^n=S_n^0+S_n^1m+S_n^2m(m-1)+S_n^3m(m-1)(m-2)+\cdots+S_n^m m!$ </center><p>这告诉我们把乘法幂转换为下降阶乘幂所需要的系数就是第二类斯特林数。</p><h2 id="特殊多项式在整点的线性插值"><a href="#特殊多项式在整点的线性插值" class="headerlink" title="特殊多项式在整点的线性插值"></a>特殊多项式在整点的线性插值</h2><p>对于一些多项式我们可以在整点上做到线性插值。详见我的博客《<a href="http://blog.rabbit-lb.cn/2018/08/07/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/">多项式的线性插值</a>》</p><h1 id="引用和参考"><a href="#引用和参考" class="headerlink" title="引用和参考"></a>引用和参考</h1><p>miskcoo@<a href="http://blog.miskcoo.com/2015/12/inversion-magic-binomial-inversion" target="_blank" rel="noopener">反演魔术：反演原理及二项式反演</a><br>vfleaking@<a href="http://vfleaking.blog.uoj.ac/blog/87" target="_blank" rel="noopener">炫酷反演魔术</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;演绎推理是我们在数学中经常遇到的一些方法。对于数列来说，通过原数列计算出新的数列叫作演绎，而通过计算出的数列反推出原数列则被称为反演。&lt;/p&gt;
&lt;p&gt;形式化地，如果原数列为 $\{f_n\}$，新数列是 $\{g_n\}$ ，且满足 &lt;/p&gt;
&lt;center&gt;$g_n=\sum_{i=0}^n a_{ni} f_i$ &lt;/center&gt;

&lt;p&gt;反演就是我们希望通过 $\{g_n\}$ 得到 $\{f_n\}$ :&lt;/p&gt;
&lt;center&gt;$f_n=\sum_{i=0}^n b_{ni} g_i$ &lt;/center&gt;

&lt;p&gt;结合一下就是&lt;/p&gt;
&lt;center&gt;$g_n=\sum_{i=0}^n a_{ni} f_i \Leftrightarrow f_n=\sum_{i=0}^n b_{ni} g_i$ &lt;/center&gt;

&lt;p&gt;数列反演有许许多多种不同的类型，就例如莫比乌斯反演，二项式反演等等。其实，我们发现反演其实就是在解方程，一些方程组有算法上固定的、特殊的解，我们对于这些特殊的算法冠以具体的名字，就例如二项式反演。&lt;/p&gt;
&lt;h1 id=&quot;二项式反演&quot;&gt;&lt;a href=&quot;#二项式反演&quot; class=&quot;headerlink&quot; title=&quot;二项式反演&quot;&gt;&lt;/a&gt;二项式反演&lt;/h1&gt;&lt;p&gt;二项式反演讲的是:&lt;/p&gt;
&lt;blockquote&gt;
 &lt;center&gt;$g_n=\sum_{i=0}^n (-1)^i C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^i C_n^i g_i$ &lt;/center&gt;

&lt;/blockquote&gt;
&lt;p&gt;这个式子高度对称，它还有一个等价形式是我们所常用的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;center&gt;$g_n=\sum_{i=0}^n C_n^i f_i \Rightarrow f_n=\sum_{i=0}^n (-1)^{n-i} C_n^i g_i$ &lt;/center&gt;

&lt;/blockquote&gt;
&lt;p&gt;其实这里应该是双箭头，但是在这里右式是反演，左式则是演绎，故我们向右推出。先来证明这个反演公式，然后介绍它的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>利用简单线性表示优化线性递推</title>
    <link href="http://blog.rabbit-lb.cn/2018/07/27/%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    <id>http://blog.rabbit-lb.cn/2018/07/27/利用简单线性表示优化线性递推/</id>
    <published>2018-07-26T16:00:00.000Z</published>
    <updated>2018-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家去看<a href="/uploads/矩阵乘法递推的优化.pdf">叉姐的论文</a>啊~</p><p>欢迎大家去看这篇文章的姊妹篇：<a href="http://blog.rabbit-lb.cn/2018/07/27/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/">特征多项式优化线性递推</a></p><p>叉姐利用了特征多项式将线性递推从矩阵快速幂的 $O(k^3 \log n)$ 优化到了 $O(k^2 \log n)$ 。</p><p>但这方法对没有学过线性代数的同学极不友好（大雾）。我们尝试利用简单线性表示干同样的事情：将线性递推的复杂度从 $O(k^3 \log n)$ 优化到了 $O(k^2 \log n)$ 。</p><h1 id="齐次线性递推"><a href="#齐次线性递推" class="headerlink" title="齐次线性递推"></a>齐次线性递推</h1><p>我们先来看一下齐次线性递推的概念。我们定义 $k$ 阶的齐次线性递推应该长这个样子：</p><center>对任意 $n \in \mathbb{N}$，有 $a_{n+k} = c_1 a_{n+k-1} + c_2 a_{n+k-2} + \cdots + c_k a_n$ ，其中 $c_1 , c_2 , \cdots , c_k \in \mathbb{N}$ 。</center> <p>其实我们还希望 $c_k \neq 0$ ,不然这就会退化成一个 $k-1$ 阶的齐次线性递推。但在大多数情况下可以不考虑这种情况，它并不影响最终的时间复杂度。</p><p>对了，在本文中，若未特别提及线性递推均为 $k$ 阶齐次线性递推。</p><h1 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h1><p>如果你学过线性相关的话，就知道线性相关和线性表示其实是等价的。</p><p>当然，假装我们什么线性代数都没学过的话，线性表示讲述的是一个数和一些数的关系:<em>如果这个数能被这些数加加减减得到，那么就称这个数能被这些数线性表示</em>。</p><p>形式化地，对于一个数 $a_n$ 和一些数 $a_0,a_1,\cdots,a_{k-1}$ ，如果存在 $p_0,p_1,\cdots,p_{k-1}$ ，使得 $a_n = p_0a_0 + p_1a_1 + \cdots +p_{k-1}a_{k-1}$ ，则称 $a_n$ 能被 $a_0,a_1,…,a_{k-1}$ 线性表示。</p><p>Q: 为什么我们要花这么大力气来求线性表示<br>A: 因为这样我们就可以根据 $p_0,p_1,\cdots,p_{k-1}$ 线性时间内求出 $a_n$。</p><h2 id="每一个-a-n-都可以被线性表示"><a href="#每一个-a-n-都可以被线性表示" class="headerlink" title="每一个 $a_n$ 都可以被线性表示"></a>每一个 $a_n$ 都可以被线性表示</h2><p>我们发现，对于每一个 $a_n$ ，他都可以被 $a_0,a_1,\cdots,a_{k-1}$ 线性表示出来。</p><p>先举个例子， 对于一个 $3$ 阶的齐次线性递推 $a_{n+3} = a_{n+2} + 2a_{n+1} - a_n $ 。我们有：</p><center> $a_0= 1a_0 + 0a_1 + 0a_2$ </center> <center> $a_1= 0a_0 + 1a_1 + 0a_2$ </center> <center> $a_2= 0a_0 + 0a_1 + 1a_2$ </center> 我们尝试继续向下推：<center> $a_3= -1a_0 + 2a_1 + 1a_2$ </center> <center> $a_4= -1a_1 + 2a_2 + 1a_3$ $= -1a_1 + 2a_2 + (-1a_0 + 2a_1 + 1a_2)$ $= -1a_0 + 1a_1 + 3a_2$ </center> <center> $a_5= -1a_2 + 2a_3 + 1a_4$ $= -1a_2 + 2(-1a_0 + 2a_1 + 1a_2) + (-1a_0 + 1a_1 + 3a_2)$ $= -3a_0 + 5a_1 + 4a_2$ </center> <p>显然我们可以一直推下去。换句话说，每一个 $a_n$ 都可以用 $a_0,a_1,a_2$ 的线性组合表示。</p><a id="more"></a><h2 id="可加性"><a href="#可加性" class="headerlink" title="可加性"></a>可加性</h2><p>可加性讲的是：如果有 </p><center>$a_n=p_0a_0+p_1a_1+\cdots+p_{k-1}a_{k-1}$ </center> <p>那么</p><center> $a_{n+x}=p_0a_x+p_1a_{x+1}+\cdots+p_{k-1}a_{x+k-1}\ ,\ x\in\mathbb{N}$ </center><p>例如我们上面得到 $a_5 = -3a_0 + 5a_1 + 4a_2$ ，那么就有 </p><center> $a_6= -3a_1 + 5a_2 + 4a_3$ $=-3a_1 + 5a_2 + 4(-1a_0 + 2a_1 + 1a_2)$ $=-4a_0+5a_1+9a_2$ </center><p>可加性挺显然的，证明就留作读者自己思考吧。</p><p>这样递推显然方便很多。</p><h2 id="优化线性递推"><a href="#优化线性递推" class="headerlink" title="优化线性递推"></a>优化线性递推</h2><p>有了这两点显然我们就可以开始优化线性递推了。</p><p>在优化线性递推之前，我们先解决一个问题：</p><blockquote><p>如果我们得到 $a_m,a_n$ 的线性表示，我们是否能得到 $a_{m+n}$ 的线性表示？如果能，时间复杂度是多少？</p></blockquote><p>假设我们得到 $a_m=p_0a_0+p_1a_1+p_2a_2+\cdots+p_{k-1}a_{k-1}$ 和 $a_n=q_0a_0+q_1a_1+q_2a_2+\cdots+q_{k-1}a_{k-1}$。</p><p>我们先用一次可加性试试：</p><center>$a_{m+n}=p_0a_n+p_1a_{n+1}+p_2a_{n+2}+\cdots+p_{k-1}a_{n+k-1}$ </center><p>我们再用几次可加性试试：</p><center>$a_{m+n}=p_0a_n+p_1a_{n+1}+p_2a_{n+2}+\cdots+p_{k-1}a_{n+k-1}$ </center><center>$=p_0(q_0a_0+q_1a_1+q_2a_2+\cdots+q_{k-1}a_{k-1})$ </center><center>$+p_1(q_0a_1+q_1a_2+q_2a_3+\cdots+q_{k-1}a_{k})$ </center><center>$+p_2(q_0a_2+q_1a_3+q_2a_4+\cdots+q_{k-1}a_{k+1})$ </center><center>$+\cdots+$ </center><center>$p_{k-1}(q_0a_{k-1}+q_1a_{k}+q_2a_{k+1}+\cdots+q_{k-1}a_{2k-2})$ </center><p>整理一下:</p><p><center>$a_{m+n}=\sum_{i=0}^{2k-2} \sum_{j=0}^{i} p_jq_{i-j} a_i$ </center><br>这个式子算下来时间复杂度是 $O(k^2)$ 。</p><p>现在我们已经可以用 $a_0,a_1,a_2,\cdots,a_{2k-2}$ 线性表示 $a_{n+m}$ 了。</p><p>下一步就简单了，我们只需要知道 $a_{k},a_{k+1},\cdots,a_{2k-2}$ 的线性表示，带入进去就可以了，这部分是可以 $O(k^2)$ 预处理的。</p><p>这样算下来，已知 $a_m,a_n$ 求 $a_{m+n}$ 的总复杂度是 $O(k^2)$ 。</p><p>于是，我们利用快速幂一样算 $a_n$ ，复杂度为 $O(k^2 \log n)$ 。</p><h2 id="补-再次优化线性递推"><a href="#补-再次优化线性递推" class="headerlink" title="补: 再次优化线性递推"></a>补: 再次优化线性递推</h2><p>相比大家都发现了我们整理下来的式子 $\sum_{i=0}^{2k-2} \sum_{j=0}^{i} p_jq_{i-j} a_i$ 其实是一个标准的卷积的形式。</p><p>那么我们根据 $a_m,a_n$ 的线性表示，利用FFT就可以轻松得到上面整理的式子。再利用多项式取模，就可以将 $a_{2k-2},a_{2k-3},\cdots,a_k$ 去掉。<br>总时间复杂度为 $O(k \log k \log n)$ 。</p><h1 id="例：Project-Euler-258-A-lagged-Fibonacci-sequence"><a href="#例：Project-Euler-258-A-lagged-Fibonacci-sequence" class="headerlink" title="例：Project Euler 258 A lagged Fibonacci sequence"></a>例：Project Euler 258 A lagged Fibonacci sequence</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义递推数列 $\{g_n\}$ ，满足</p><ul><li>初值: 对于 $n &lt; 2000$,有 $g_n = 1$，</li><li>递推式：对于 $n \geq 2000$ ,有 $g_n=g_{n-2000}+g_{n-1999}$</li></ul><p>求 $g_{10^{18}} \mod 20092010$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这有什么好分析的。就是两千阶的线性递推吗。直接上代码得了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">20092010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k=<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *p,<span class="keyword">long</span> <span class="keyword">long</span> *q,<span class="keyword">long</span> <span class="keyword">long</span> *c)</span> <span class="comment">//p,q为a_n,a_m的一种线性表示，c为系数数组，函数算出a_&#123;m+n&#125;的线性表示并存在数组p中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp[<span class="number">2</span>*k];</span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            tmp[i+j]=(tmp[i+j]+p[i]*q[j])%mod; <span class="comment">//利用可加性将a_&#123;m+n&#125;利用(a_0,a_1,...,a_&#123;2k-2&#125;)线性表示，并把系数存在tmp中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k<span class="number">-2</span>;i&gt;=k;i--) <span class="comment">//利用a_n=c_0a_&#123;n-1&#125;+c_1a_&#123;n-2&#125;+...+c_ka_&#123;n-k&#125; 将 a_i 转化为 a_&#123;i-1&#125;,a_&#123;i-2&#125;,...,a_&#123;i-k&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(tmp[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++) <span class="comment">//这样依次转化 a_&#123;2k-2&#125;,a_&#123;2k-3&#125;,...,a_k 就可以得到我们想要的线性表示</span></span><br><span class="line">                <span class="keyword">if</span>(c[j])</span><br><span class="line">                    tmp[i-j<span class="number">-1</span>]=(tmp[i-j<span class="number">-1</span>]+tmp[i]*c[j])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        p[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *a,<span class="keyword">long</span> <span class="keyword">long</span> *c,<span class="keyword">long</span> <span class="keyword">long</span> n)</span> <span class="comment">//a为初始值数组 c为系数数组 和上文线性递推定义对应</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  if(k==1) return pw(c[0],n-1)*a[0]%mod;</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;k) <span class="keyword">return</span> a[n]; <span class="comment">//如果已知就直接返回</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp[k],res[k]; <span class="comment">//初始化快速幂，tmp存 a_&#123;2^x&#125; ，res存答案</span></span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));<span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">    tmp[<span class="number">1</span>]=res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) mul(res,tmp,c);</span><br><span class="line">        mul(tmp,tmp,c);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        ans=(ans+a[i]*res[i])%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[k],c[k];</span><br><span class="line">    fill(a,a+k,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    c[<span class="number">1998</span>]=c[<span class="number">1999</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(a,c,<span class="number">1e18</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家去看&lt;a href=&quot;/uploads/矩阵乘法递推的优化.pdf&quot;&gt;叉姐的论文&lt;/a&gt;啊~&lt;/p&gt;
&lt;p&gt;欢迎大家去看这篇文章的姊妹篇：&lt;a href=&quot;http://blog.rabbit-lb.cn/2018/07/27/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/&quot;&gt;特征多项式优化线性递推&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;叉姐利用了特征多项式将线性递推从矩阵快速幂的 $O(k^3 \log n)$ 优化到了 $O(k^2 \log n)$ 。&lt;/p&gt;
&lt;p&gt;但这方法对没有学过线性代数的同学极不友好（大雾）。我们尝试利用简单线性表示干同样的事情：将线性递推的复杂度从 $O(k^3 \log n)$ 优化到了 $O(k^2 \log n)$ 。&lt;/p&gt;
&lt;h1 id=&quot;齐次线性递推&quot;&gt;&lt;a href=&quot;#齐次线性递推&quot; class=&quot;headerlink&quot; title=&quot;齐次线性递推&quot;&gt;&lt;/a&gt;齐次线性递推&lt;/h1&gt;&lt;p&gt;我们先来看一下齐次线性递推的概念。我们定义 $k$ 阶的齐次线性递推应该长这个样子：&lt;/p&gt;
&lt;center&gt;对任意 $n \in \mathbb{N}$，有 $a_{n+k} = c_1 a_{n+k-1} + c_2 a_{n+k-2} + \cdots + c_k a_n$ ，其中 $c_1 , c_2 , \cdots , c_k \in \mathbb{N}$ 。&lt;/center&gt; 

&lt;p&gt;其实我们还希望 $c_k \neq 0$ ,不然这就会退化成一个 $k-1$ 阶的齐次线性递推。但在大多数情况下可以不考虑这种情况，它并不影响最终的时间复杂度。&lt;/p&gt;
&lt;p&gt;对了，在本文中，若未特别提及线性递推均为 $k$ 阶齐次线性递推。&lt;/p&gt;
&lt;h1 id=&quot;线性表示&quot;&gt;&lt;a href=&quot;#线性表示&quot; class=&quot;headerlink&quot; title=&quot;线性表示&quot;&gt;&lt;/a&gt;线性表示&lt;/h1&gt;&lt;p&gt;如果你学过线性相关的话，就知道线性相关和线性表示其实是等价的。&lt;/p&gt;
&lt;p&gt;当然，假装我们什么线性代数都没学过的话，线性表示讲述的是一个数和一些数的关系:&lt;em&gt;如果这个数能被这些数加加减减得到，那么就称这个数能被这些数线性表示&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;形式化地，对于一个数 $a_n$ 和一些数 $a_0,a_1,\cdots,a_{k-1}$ ，如果存在 $p_0,p_1,\cdots,p_{k-1}$ ，使得 $a_n = p_0a_0 + p_1a_1 + \cdots +p_{k-1}a_{k-1}$ ，则称 $a_n$ 能被 $a_0,a_1,…,a_{k-1}$ 线性表示。&lt;/p&gt;
&lt;p&gt;Q: 为什么我们要花这么大力气来求线性表示&lt;br&gt;A: 因为这样我们就可以根据 $p_0,p_1,\cdots,p_{k-1}$ 线性时间内求出 $a_n$。&lt;/p&gt;
&lt;h2 id=&quot;每一个-a-n-都可以被线性表示&quot;&gt;&lt;a href=&quot;#每一个-a-n-都可以被线性表示&quot; class=&quot;headerlink&quot; title=&quot;每一个 $a_n$ 都可以被线性表示&quot;&gt;&lt;/a&gt;每一个 $a_n$ 都可以被线性表示&lt;/h2&gt;&lt;p&gt;我们发现，对于每一个 $a_n$ ，他都可以被 $a_0,a_1,\cdots,a_{k-1}$ 线性表示出来。&lt;/p&gt;
&lt;p&gt;先举个例子， 对于一个 $3$ 阶的齐次线性递推 $a_{n+3} = a_{n+2} + 2a_{n+1} - a_n $ 。我们有：&lt;/p&gt;
&lt;center&gt; $a_0= 1a_0 + 0a_1 + 0a_2$ &lt;/center&gt; 
&lt;center&gt; $a_1= 0a_0 + 1a_1 + 0a_2$ &lt;/center&gt; 
&lt;center&gt; $a_2= 0a_0 + 0a_1 + 1a_2$ &lt;/center&gt; 
我们尝试继续向下推：
&lt;center&gt; $a_3= -1a_0 + 2a_1 + 1a_2$ &lt;/center&gt; 
&lt;center&gt; $a_4= -1a_1 + 2a_2 + 1a_3$ $= -1a_1 + 2a_2 + (-1a_0 + 2a_1 + 1a_2)$ $= -1a_0 + 1a_1 + 3a_2$ &lt;/center&gt; 
&lt;center&gt; $a_5= -1a_2 + 2a_3 + 1a_4$ $= -1a_2 + 2(-1a_0 + 2a_1 + 1a_2) + (-1a_0 + 1a_1 + 3a_2)$ $= -3a_0 + 5a_1 + 4a_2$ &lt;/center&gt; 

&lt;p&gt;显然我们可以一直推下去。换句话说，每一个 $a_n$ 都可以用 $a_0,a_1,a_2$ 的线性组合表示。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://blog.rabbit-lb.cn/categories/OI/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性代数" scheme="http://blog.rabbit-lb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="OI" scheme="http://blog.rabbit-lb.cn/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>特征多项式优化线性递推</title>
    <link href="http://blog.rabbit-lb.cn/2018/07/27/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/"/>
    <id>http://blog.rabbit-lb.cn/2018/07/27/特征多项式优化线性递推/</id>
    <published>2018-07-26T16:00:00.000Z</published>
    <updated>2018-08-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家去看<a href="/uploads/矩阵乘法递推的优化.pdf">叉姐的论文</a>啊~</p><p>欢迎大家去看这篇文章的姊妹篇：<a href="http://blog.rabbit-lb.cn/2018/07/27/%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/">利用简单线性表示优化线性递推</a></p><p>假设大家都学过矩阵快速幂了，下面主要讲将特征多项式黑科技。</p><h1 id="温习：矩阵快速幂"><a href="#温习：矩阵快速幂" class="headerlink" title="温习：矩阵快速幂"></a>温习：矩阵快速幂</h1><p>对于一个 $k$ 次的线性递推: </p><center>$ h_n = a_1 h_{n-1} + a_2 h_{n-2} + ... + a_k h_{n-k} , \forall\ n \in \mathbb{N}\ ,\ n > k $</center><p>我们构造转移矩阵 </p><center>$ A = \begin{bmatrix} a_1 & a_2 & \cdots & a_{k-2} & a_{k-1} & a_k\\ 1 & 0 & \cdots & 0 & 0 & 0\\ 0 & 1 & \cdots & 0 & 0 & 0\\ \vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\ 0 & 0 & \cdots & 1 & 0 & 0\\ 0 & 0 & \cdots & 0 & 1 & 0 \end{bmatrix}_{k \times k}$</center><p>和初始向量 </p><center> $x = \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix}_{k \times 1}$ </center><p>易见</p><center> $Ax = \begin{bmatrix} a_1 & a_2 & \cdots & a_{k-2} & a_{k-1} & a_k\\ 1 & 0 & \cdots & 0 & 0 & 0\\ 0 & 1 & \cdots & 0 & 0 & 0\\ \vdots & \vdots & \ddots & \vdots & \vdots & \vdots\\ 0 & 0 & \cdots & 1 & 0 & 0\\ 0 & 0 & \cdots & 0 & 1 & 0 \end{bmatrix} \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix} = \begin{bmatrix} h_k \\ h_{k-1} \\ \vdots \\ h_3 \\ h_2 \\ h_1 \end{bmatrix} $</center><p>显然这样可以顺次推下去，于是我们只要得到 $A^{n-k+1}x$ 就可以得到 $ h_n $ ，由于一次矩阵乘法复杂度为 $ O(k^3) $ <del>(听说可以更小一点，但我不会。。。)</del> 矩阵乘法又满足快速幂性质，可以类比普通乘法快速幂得到一个 $O(k^3 \log n)$ 的优秀做法。</p><p>但是这个复杂度依然不够优秀，我们把眼光放到线性代数上。<br><a id="more"></a></p><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>我在这章将直接给出结论。在本文的结尾会补充一些线性代数的内容。</p><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><blockquote><p>若非零向量 $x$ 有 $Ax = \lambda x\ $ , 则称 $x$ 为 $A$ 的一个特征向量 ， $\lambda$ 是其对应的特征值。</p></blockquote><h2 id="特征多项式"><a href="#特征多项式" class="headerlink" title="特征多项式"></a>特征多项式</h2><p>我们记矩阵 $A$ 的特征多项式 $f(\lambda)=|A - \lambda I|$。 令 $f(\lambda)=0$ 解得的 $\lambda$ 即为矩阵 $A$ 的特征值。</p><h2 id="化零多项式"><a href="#化零多项式" class="headerlink" title="化零多项式"></a>化零多项式</h2><p>对于一个多项式 $ f(x) = p_0 x^0 + p_1 x^1 + … + p_n x^n $ 和一个矩阵 $ A $ , 若有 $f(A) = p_0 A^0 + p_1 A^1 + … + p_n A^n = 0$ ，则称 $f(A)$ 是矩阵 $A$ 的一个化零多项式。</p><h2 id="Caylay-Camilton-定理"><a href="#Caylay-Camilton-定理" class="headerlink" title="Caylay-Camilton 定理"></a>Caylay-Camilton 定理</h2><p>凯莱-哈密尔顿定理十分简洁。</p><blockquote><p>Caylay-Camilton 定理: 一个矩阵的特征多项式是它的化零多项式</p></blockquote><p>即若有矩阵 $A$ 的特征多项式 $f(\lambda)= p_0 \lambda^0 + p_1 \lambda^1 + … + p_n \lambda^n $ ，则 $f(A) = p_0 A^0 + p_1 A^1 + … + p_n A^n = 0$ 。</p><h1 id="特征多项式优化线性递推"><a href="#特征多项式优化线性递推" class="headerlink" title="特征多项式优化线性递推"></a>特征多项式优化线性递推</h1><h2 id="线性递推的小结论"><a href="#线性递推的小结论" class="headerlink" title="线性递推的小结论"></a>线性递推的小结论</h2><p>对于线性递推 $a_{n+k}=c_1a_{n+k-1}+c_2a_{n+k-2}+…+c_ka_n$ ，它的转移矩阵的特征多项式是</p><center>$A^k=c_1A^{k-1}+c_2A^{k-2}+...+c_{n-1}A+c_nI$ </center><h2 id="优化开始"><a href="#优化开始" class="headerlink" title="优化开始"></a>优化开始</h2><p>我们其实发现矩阵快速幂求得就是 $A^{n-k+1}x$ 。我们考虑将 $A^x$ 降次。</p><p>其实我们发现 $A^x=c_1A^{x-1}+c_2A^{x-2}+…+c_kA^{x-k}$ ，就可以把 $A^x$ 降次为 $A^{x-1},A^{x-2},…,A^{x-k}$ ，如果我们按着这样降次下去，就可以将 $A^{n-k+1}$ 降次到 $I,A,A^2,…,A^{k-1}$ 的线性组合。这样做的时间复杂度是 $O(nk)$ ，这显然是不够优秀的。</p><p>不过，如果我们得到 $A^n=p_0I+p_1A+p_2A^2+…+p_{k-1}A^{k-1}$ 和 $A^m=q_0I+q_1A+q_2A^2+…+q_{k-1}A^{k-1}$ ，就有 $A^{n+m}=A^nA^m$ $=(p_0I+p_1A+p_2A^2+…+p_{k-1}A^{k-1})(q_0I+q_1A+q_2A^2+…+q_{k-1}A^{k-1})$ $=\sum_{i=0}^{2k-2} \sum_{j=0}^i p_jq_{i-j} A^i$ </p><p>我们在这里得到一个次数为 $2k-2$ 的多项式，我们用上面降次的方法将多项式降到最高次数 $k-1$ 的多项式。</p><p>如果我们暴力计算多项式乘积的话，多项式乘积的时间复杂度是 $O(k^2)$ 的。如果我们暴力降次的话，时间复杂度是 $O(k^2)$ 。于是一次乘法的总复杂度为 $O(k^2)$ 。利用快速幂，我们可以做到 $O(k^2 \log n)$ 。</p><p>如果想要继续优化的话，我们可以利用FFT来代替暴力多项式乘法，复杂度 $O(k \log k)$。利用多项式取模来代替暴力降次，复杂度 $O(k \log k)$ 。于是一次乘法总复杂度为 $O(k \log k)$ 。利用快速幂，我们可以做到 $O(k \log k \log n)$ 。</p><h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><ol><li>当然了我们不会直接记 $A^x$ ，我们只需要记 $A^x=p_0I+p_1A+p_2A^2+…+p_{k-1}A^{k-1}$ 中的 $\{p_0,p_1,…,p_{k-1}\}$ 就可以了</li><li>我们也我们也不需要直接算出 $I,A,A^2,…,A^{k-1}$ 这样的话的复杂度是 $O(k^3)$ 这是我们不能接受的。事实上，我们只需要计算出 $x,Ax,A^2x,A^3x,…,A^{k-1}x$ 就可以了。时间复杂度是 $O(k^2)$ 。</li><li>我们甚至不需要算 $x,Ax,A^2x,…,A^{k-1}x$。因为我们最后关注的 $a_n$ 其实只是 $A^{n-k+1}x$ 的最后一项，我们只需要考虑 $x,Ax,A^2x,…A^{k-1}x$ 的最后一项就可以了。在这里 $x,Ax,A^2x,…,A^{k-1}x$ 的最后一项正好分别是 $a_0,a_1,…,a_{k-1}$ </li><li>总结一下 $2,3$ 就是说：在线性递推中，如果我们算到 $A^{n-k+1}=p_0I+p_1A+p_2A^2+…+p_{k-1}A^{k-1}$ 那么 $a_n=p_0a_0+p_1a_1+…+p_{k-1}a_{k-1}$ </li></ol><h1 id="例：Project-Euler-258-A-lagged-Fibonacci-sequence"><a href="#例：Project-Euler-258-A-lagged-Fibonacci-sequence" class="headerlink" title="例：Project Euler 258 A lagged Fibonacci sequence"></a>例：Project Euler 258 A lagged Fibonacci sequence</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>定义递推数列 $\{g_n\}$ ，满足</p><ul><li>初值: 对于 $n &lt; 2000$,有 $g_n = 1$，</li><li>递推式：对于 $n \geq 2000$ ,有 $g_n=g_{n-2000}+g_{n-1999}$</li></ul><p>求 $g_{10^{18}} \mod 20092010$。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这有什么好分析的。就是两千阶的线性递推吗。直接上代码得了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">20092010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k=<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *p,<span class="keyword">long</span> <span class="keyword">long</span> *q,<span class="keyword">long</span> <span class="keyword">long</span> *c)</span> <span class="comment">//p,q为A^n,A^m降次后的系数，c为递推系数数组，函数算出a^&#123;m+n&#125;降次之后的系数并存在数组p中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp[<span class="number">2</span>*k];</span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            tmp[i+j]=(tmp[i+j]+p[i]*q[j])%mod; <span class="comment">//利用可加性将a_&#123;m+n&#125;利用(a_0,a_1,...,a_&#123;2k-2&#125;)线性表示，并把系数存在tmp中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k<span class="number">-2</span>;i&gt;=k;i--) <span class="comment">//利用a_n=c_0a_&#123;n-1&#125;+c_1a_&#123;n-2&#125;+...+c_ka_&#123;n-k&#125; 将 a_i 转化为 a_&#123;i-1&#125;,a_&#123;i-2&#125;,...,a_&#123;i-k&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(tmp[i])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++) <span class="comment">//这样依次转化 a_&#123;2k-2&#125;,a_&#123;2k-3&#125;,...,a_k 就可以得到我们想要的线性表示</span></span><br><span class="line">                <span class="keyword">if</span>(c[j])</span><br><span class="line">                    tmp[i-j<span class="number">-1</span>]=(tmp[i-j<span class="number">-1</span>]+tmp[i]*c[j])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        p[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> *a,<span class="keyword">long</span> <span class="keyword">long</span> *c,<span class="keyword">long</span> <span class="keyword">long</span> n)</span> <span class="comment">//a为初始值数组 c为系数数组 和上文线性递推定义对应</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  if(k==1) return pw(c[0],n-1)*a[0]%mod;</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;k) <span class="keyword">return</span> a[n]; <span class="comment">//如果已知就直接返回</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp[k],res[k]; <span class="comment">//初始化快速幂，tmp存 A^&#123;2^x&#125; ，res存答案</span></span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(tmp));<span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">    tmp[<span class="number">1</span>]=res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) mul(res,tmp,c);</span><br><span class="line">        mul(tmp,tmp,c);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        ans=(ans+a[i]*res[i])%mod; <span class="comment">//a_n=p_0a_0+p_1a_1+...+p_&#123;k-1&#125;a_&#123;k-1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[k],c[k];</span><br><span class="line">    fill(a,a+k,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    c[<span class="number">1998</span>]=c[<span class="number">1999</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solve(a,c,<span class="number">1e18</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="特征向量和特征值"><a href="#特征向量和特征值" class="headerlink" title="特征向量和特征值"></a>特征向量和特征值</h2><p>我们考虑矩阵的几何意义。矩阵其实等价于坐标的线性变换。比方说一个 $2\times2$ 的方阵可以通过乘上一个二维平面直角坐标，得到新的二维平面直角坐标。这就是坐标变换。<br>我们并不喜欢用坐标这个词，这很不线性代数。我们引入向量————有方向的量，来代替坐标。一个坐标对应的向量，长度为坐标到原点的距离，方向为从原点出发，经过坐标的射线的方向。<br>有趣的是，在坐标变换前后，有些向量方向改变，有些向量方向则不变（或变成其反方向）。<br>我们称那些坐标变换前后方向不变或者变成其反方向的<strong>非零</strong>向量叫作特征向量，其前后的长度之比记为其特征值。特征值的正负号取决于方向是与原来相同还是恰好相反。</p><h2 id="特征多项式-1"><a href="#特征多项式-1" class="headerlink" title="特征多项式"></a>特征多项式</h2><p>为了求出所有特征值，我们尝试解方程 $Ax = \lambda x$ 。</p><p>移项得到 $(A - \lambda I) x = 0 $ , 由于 $x$ 为非零向量 ， 故 $A-\lambda I$ 一定不可逆（否则等式两边左乘其逆矩阵，得到 $x = 0$) ，故有 $A - \lambda I$ 特征值为 $0$ ，即$|A - \lambda I|=0$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家去看&lt;a href=&quot;/uploads/矩阵乘法递推的优化.pdf&quot;&gt;叉姐的论文&lt;/a&gt;啊~&lt;/p&gt;
&lt;p&gt;欢迎大家去看这篇文章的姊妹篇：&lt;a href=&quot;http://blog.rabbit-lb.cn/2018/07/27/%E5%88%A9%E7%94%A8%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%A4%BA%E4%BC%98%E5%8C%96%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8/&quot;&gt;利用简单线性表示优化线性递推&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设大家都学过矩阵快速幂了，下面主要讲将特征多项式黑科技。&lt;/p&gt;
&lt;h1 id=&quot;温习：矩阵快速幂&quot;&gt;&lt;a href=&quot;#温习：矩阵快速幂&quot; class=&quot;headerlink&quot; title=&quot;温习：矩阵快速幂&quot;&gt;&lt;/a&gt;温习：矩阵快速幂&lt;/h1&gt;&lt;p&gt;对于一个 $k$ 次的线性递推: &lt;/p&gt;
&lt;center&gt;$ h_n = a_1 h_{n-1} + a_2 h_{n-2} + ... + a_k h_{n-k} , \forall\ n \in \mathbb{N}\ ,\ n &gt; k $&lt;/center&gt;

&lt;p&gt;我们构造转移矩阵 &lt;/p&gt;
&lt;center&gt;$ A = \begin{bmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_{k-2} &amp; a_{k-1} &amp; a_k\\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots\\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}_{k \times k}$&lt;/center&gt;

&lt;p&gt;和初始向量 &lt;/p&gt;
&lt;center&gt; $x = \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix}_{k \times 1}$ &lt;/center&gt;

&lt;p&gt;易见&lt;/p&gt;
&lt;center&gt; $Ax = \begin{bmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_{k-2} &amp; a_{k-1} &amp; a_k\\ 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots\\ 0 &amp; 0 &amp; \cdots &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} h_{k-1} \\ h_{k-2} \\ \vdots \\ h_2 \\ h_1 \\ h_0 \end{bmatrix} = \begin{bmatrix} h_k \\ h_{k-1} \\ \vdots \\ h_3 \\ h_2 \\ h_1 \end{bmatrix} $&lt;/center&gt;

&lt;p&gt;显然这样可以顺次推下去，于是我们只要得到 $A^{n-k+1}x$ 就可以得到 $ h_n $ ，由于一次矩阵乘法复杂度为 $ O(k^3) $ &lt;del&gt;(听说可以更小一点，但我不会。。。)&lt;/del&gt; 矩阵乘法又满足快速幂性质，可以类比普通乘法快速幂得到一个 $O(k^3 \log n)$ 的优秀做法。&lt;/p&gt;
&lt;p&gt;但是这个复杂度依然不够优秀，我们把眼光放到线性代数上。&lt;br&gt;
    
    </summary>
    
      <category term="OI" scheme="http://blog.rabbit-lb.cn/categories/OI/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性代数" scheme="http://blog.rabbit-lb.cn/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="OI" scheme="http://blog.rabbit-lb.cn/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>再探π^2/6</title>
    <link href="http://blog.rabbit-lb.cn/2018/06/26/%E5%86%8D%E6%8E%A2%CF%80%5E2%C3%B76/"/>
    <id>http://blog.rabbit-lb.cn/2018/06/26/再探π^2÷6/</id>
    <published>2018-06-25T16:00:00.000Z</published>
    <updated>2018-08-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们知道无穷级数 $\sum_{n\geq1} \frac{1}{n}=O(n\ln n)$ 发散。事实上，质数的倒数和 $\sum_{p\in \mathbb{P}} \frac{1}{p}=O(n\ln \ln n)$  同样发散。简单证明可以看我的博客 《<a href="http://blog.rabbit-lb.cn/2018/08/08/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0%E7%9B%B8%E5%85%B3%E2%80%94%E2%80%94%E8%B4%A8%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E5%92%8C%E5%A2%9E%E9%95%BF%E9%80%9F%E5%BA%A6%E4%B8%BAlnlnn/">调和级数相关——质数的倒数和增长速度为O(ln ln n)</a>》。</p><p>​    尽管如此，平方的倒数和收敛（尽管收敛地很慢，我们将看到），而且收敛于一个有趣的数。</p><blockquote><p><strong>欧拉级数</strong></p><blockquote><p>$\sum_{n \geq 1} \frac{1}{n^2}=\frac{\pi^2}{6}$ </p></blockquote></blockquote><p>​    这是 1734 年 Leonhard Euler 做出的一个经典、著名且重要的结果。这个事实的一个重要解释是它导出了 Riemann zeta 函数的第一个非平凡值 $\zeta(2)=\frac{\pi^2}{6}$ 。不仅这一结果在数学史上有显赫的地位，它的几个极其优美聪明的证明也拥有自己的历史。本文就分享几个极为精妙的证明。</p><h1 id="Euler-的证明"><a href="#Euler-的证明" class="headerlink" title="Euler 的证明"></a>Euler 的证明</h1><p>​    Euler 当然是十分聪明的，这个证明也十分优美。首先注意到 $\sin x$  的泰勒展开<br>​                    <center>$$\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+...$$</center><br>​    从而<br>​                    <center>$\frac{\sin x}{x}=1-\frac{x^2}{3!}+\frac{x^4}{5!}-\frac{x^6}{7!}+...$</center><br>​    令 $\frac{\sin x}{x}=0$ 解得 $x=k \pi (k \in \mathbb{Z}$ 且 $k \neq 0)$<br>​    故我们将 $\frac{\sin x}{x}$ 因式分解<br>​                    <center>$\frac{\sin x}{x}=(1-\frac{x}{\pi})(1+\frac{x}{\pi})(1-\frac{x}{2\pi})(1+\frac{x}{2\pi})(1-\frac{x}{3\pi})(1+\frac{x}{3\pi})...$</center><br>​                        <center>$=(1-\frac{x^2}{\pi^2})(1-\frac{x^2}{4\pi^2})(1-\frac{x^2}{9\pi^2})...$</center><br>​    （Euler 似乎并没有证明这个因式分解的正确性。幸运的是，一个世纪以后，Weierstrass 提出了著名的 Weierstrass 分解定理，利用复分析证明了这个结论。）<br>​    考虑这个因式分解的 $x^2$ 项前系数，对比泰勒展开式，可以知道<br>​                    <center>$-(\frac{1}{\pi^2}+\frac{1}{4\pi^2}+\frac{1}{9\pi^2}+...)=-\frac{1}{3!}=-\frac{1}{6}$</center><br>​    两边同乘 $-\pi^2$ 即<br>​                    <center>$\sum_{n \geq 1} \frac{1}{n^2}=\frac{\pi^2}{6}$</center><br>​    证毕<br><a id="more"></a></p><h1 id="初等数学证明"><a href="#初等数学证明" class="headerlink" title="初等数学证明"></a>初等数学证明</h1><p>​    在所有证明中间，这个可能是最初等的证明。只需要知道三角函数和韦达定理，就可以基本上证明了。<br>​    我们首先建立关于余切函数和多项式之间的关系<br>​                    <center>$\sum_{i=1}^{m} \cot^2(\frac{i}{2m+1}\pi) =\frac{2m(2m-1)}{6}$</center><br>​    为了验证这个关系，我们从<br>​                    <center>$\cos nx +i\sin nx =(\cos x +i\sin x)^n$</center><br>​    开始，取虚部，得<br>​                    <center>$\sin nx =C_n^1 \sin x\cos^{n-1} x-C_n^3\sin^3 x\cos^{n-3} x+...$</center><br>​    令 $n=2m+1$ ，两边同除 $\sin^n x$  得到<br>​                     <center>$\frac{\sin((2m+1)x)}{\sin^{2m+1} x} =C_{2m+1}^1 \cot^{2m} x-C_{2m+1}^3 x\cot^{2m} x+...$</center><br>​    令 $x=\frac{i}{2m+1}\pi\ (i=1,2,…,m)$ ，左边 $\sin((2m+1)x)=0$ ，于是都有<br>​                    <center>$0=C_{2m+1}^1 \cot^{2m} x-C_{2m+1}^3 x\cot^{2m} x+...$</center><br>​    因此方程<br>​                    <center>$C_{2m+1}^1t^m-C_{2m+1}^3t^{m-1}+...+(-1)^mC_{2m+1}^{2m+1}=0$</center><br>​    有 $m$ 个不同的根<br>​                    <center>$t_i=\cot^2(\frac{i}{2m+1}\pi)\ (i=1,2,...,m)$</center><br>​    由韦达定理可知 $m$ 根之和为<br>​                    <center>$\sum_{i=1}^{m} \cot^2(\frac{i}{2m+1}\pi) =\frac{C_{2m+1}^{3}}{C_{2m+1}^{1}}=\frac{2m(2m-1)}{6}$</center><br>​    这样我们就得到了关于余切函数和多项式之间的关系。根据余割函数和余切函数之间的关系，同样的我们也可以建立余割函数和多项式之间的关系<br>​                    <center>$\sum_{i=1}^{m} \csc^2(\frac{i}{2m+1}\pi) =\sum_{i=1}^{m} 1+\cot^2(\frac{i}{2m+1}\pi) =\frac{2m(2m-1)}{6}+m=\frac{2m(2m+1)}{6}$</center><br>​    这样我们的准备工作已经全部准备好了，现在到了大展身手的时候</p><p>​    考虑 $y\in(0,\frac{\pi}{2})$  有<br>​                    <center>$0 < \sin y < y < \tan y $</center><br>​    从而<br>​                    <center>$0 < \cot y < \frac{1}{y} < \csc y $</center><br>​    这表明<br>​                    <center>$0 < \cot^2 y < \frac{1}{y^2} < \csc^2 y$</center><br>​    现在把 $t$ 的 $m$ 个不同根带入，左边用余切函数平方和，右边用余割函数平方和，可以得到<br>​                    <center>$\frac{2m(2m-1)}{6} < (\frac{2m+1}{\pi})^2+(\frac{2m+1}{2\pi})^2+...+(\frac{2m+1}{m\pi})^2 < \frac{2m(2m+2)}{6}$</center><br>​    两边同乘 $\frac{(2m+1)^2}{\pi^2}$ 可得<br>​                    <center>$\frac{\pi^2}{6}\frac{2m(2m-1)}{(2m+1)^2} < \frac{1}{1^2}+\frac{1}{2^2}+...+\frac{1}{m^2} < \frac{\pi^2}{6}\frac{2m(2m+2)}{(2m+1)^2}$</center><br>​    当 $m$ 趋近于 $\infty$ 时，左右两端都收敛到 $\frac{\pi^2}{6}$ 。证毕。</p><p>还有一些极为简短的证明，下面分享两个。</p><h1 id="傅里叶分析"><a href="#傅里叶分析" class="headerlink" title="傅里叶分析"></a>傅里叶分析</h1><p>​    考虑函数 $f(x)=x^2$ ，$x\in (-\pi,\pi) $ ,将其傅里叶展开<br>​                    <center>$f(x)=\frac{\pi^2}{3}+\sum_{n=1}^{\infty} ((-1)^n\frac{4}{n^2}\cos nx)$</center><br>​    显而易见，带入 $f(0)$ 即可得到答案</p><h1 id="伯努利数的证明"><a href="#伯努利数的证明" class="headerlink" title="伯努利数的证明"></a>伯努利数的证明</h1><p>​    函数 $B(x)=\frac{x}{e^x-1}$ 是伯努利数 $B_k$ 的生成函数，有 $B$ 是亚纯，且只在 $2n\pi i$ 处有极点，利用Mittag-Leffler定理可以展开为<br>​        <center>$\frac{x}{e^x-1}=\sum_ {n\in\mathbb{Z}}\frac{2n\pi i}{x-2n\pi i}=\sum_{n\in\mathbb{Z}}-\frac{1}{1-\frac{x}{2n\pi i}}=-\sum _{n\in\mathbb{Z}} (\frac{x}{2n\pi i})^k =\sum _{n \geq 0} (-1)^{n+1}\frac{2\zeta(2n)}{(2\pi)^{2n}}x^{2n}$</center><br>​        其中 $\zeta(s)$ 为Riemann zeta 函数，对实数 $s&gt;1$ 定义为 $\zeta(s)=\sum_{n \geq 1} \frac{1}{n^s}$ </p><p>​    只剩下偶数项是因为几何级数正负相消了，同时我们也可以得到奇数项的伯努利数为 $0$ ,对比偶数项可知<br>​                            <center>$B_{2n}=(-1)^{n+1}\frac{2\zeta(2n)}{(2\pi)^{2n}}$</center><br>​    所以 $\frac{2\zeta(2)}{(2\pi)^{2}}=B_2=\frac{1}{12}$ ，于是 $\zeta(2)=\frac{\pi^2}{6}$ ,证毕。</p><h1 id="应用：任意两个正整数互质的概率"><a href="#应用：任意两个正整数互质的概率" class="headerlink" title="应用：任意两个正整数互质的概率"></a>应用：任意两个正整数互质的概率</h1><p>​    为了求任意两个正整数互质的概率。记 $p_i$ 为从小到大第 $i$ 个质数。则有任意一个正整数被 $p_i$ 整除的概率为$\frac{1}{p_i}$ ,故任选两个正整数都被 $p_i$ 整除的概率为 $\frac{1}{p_i^2}$ 。于是可以得到任意两个正整数互质的概率为<br>​        <center>$\Pi _{i \in \mathbb{N}*} (1-\frac{1}{p_i^2}) =\frac{1}{\Pi _{i \in \mathbb{N}*} \frac{1}{1-\frac{1}{p_i^2} }} =\frac{1}{\Pi _{i \in \mathbb{N*}}(1+\frac{1}{p_i^2}+\frac{1}{p_i^4}+\frac{1}{p_i^6}+...) }=\frac{1}{\sum _{n \in \mathbb{N*}}\frac{1}{n^2}}=\frac{6}{\pi^2}$</center><br>​​    其中<br>​        <center>$\Pi _{i \in \mathbb{N*}}(1+\frac{1}{p_i^2}+\frac{1}{p_i^4}+\frac{1}{p_i^6}+...) =\sum _{n \in \mathbb{N*}}\frac{1}{n^2}$</center><br>​    是由于算数基本定理，任何正整数质因数分解唯一。</p><p>故任意两个正整数互质的概率为 $\frac{6}{\pi^2} $ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    我们知道无穷级数 $\sum_{n\geq1} \frac{1}{n}=O(n\ln n)$ 发散。事实上，质数的倒数和 $\sum_{p\in \mathbb{P}} \frac{1}{p}=O(n\ln \ln n)$  同样发散。简单证明可以看我的博客 《&lt;a href=&quot;http://blog.rabbit-lb.cn/2018/08/08/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0%E7%9B%B8%E5%85%B3%E2%80%94%E2%80%94%E8%B4%A8%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E5%92%8C%E5%A2%9E%E9%95%BF%E9%80%9F%E5%BA%A6%E4%B8%BAlnlnn/&quot;&gt;调和级数相关——质数的倒数和增长速度为O(ln ln n)&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;​    尽管如此，平方的倒数和收敛（尽管收敛地很慢，我们将看到），而且收敛于一个有趣的数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;欧拉级数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\sum_{n \geq 1} \frac{1}{n^2}=\frac{\pi^2}{6}$ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    这是 1734 年 Leonhard Euler 做出的一个经典、著名且重要的结果。这个事实的一个重要解释是它导出了 Riemann zeta 函数的第一个非平凡值 $\zeta(2)=\frac{\pi^2}{6}$ 。不仅这一结果在数学史上有显赫的地位，它的几个极其优美聪明的证明也拥有自己的历史。本文就分享几个极为精妙的证明。&lt;/p&gt;
&lt;h1 id=&quot;Euler-的证明&quot;&gt;&lt;a href=&quot;#Euler-的证明&quot; class=&quot;headerlink&quot; title=&quot;Euler 的证明&quot;&gt;&lt;/a&gt;Euler 的证明&lt;/h1&gt;&lt;p&gt;​    Euler 当然是十分聪明的，这个证明也十分优美。首先注意到 $\sin x$  的泰勒展开&lt;br&gt;​                    &lt;center&gt;$$\sin x=x-\frac{x^3}{3!}+\frac{x^5}{5!}-\frac{x^7}{7!}+...$$&lt;/center&gt;&lt;br&gt;​    从而&lt;br&gt;​                    &lt;center&gt;$\frac{\sin x}{x}=1-\frac{x^2}{3!}+\frac{x^4}{5!}-\frac{x^6}{7!}+...$&lt;/center&gt;&lt;br&gt;​    令 $\frac{\sin x}{x}=0$ 解得 $x=k \pi (k \in \mathbb{Z}$ 且 $k \neq 0)$&lt;br&gt;​    故我们将 $\frac{\sin x}{x}$ 因式分解&lt;br&gt;​                    &lt;center&gt;$\frac{\sin x}{x}=(1-\frac{x}{\pi})(1+\frac{x}{\pi})(1-\frac{x}{2\pi})(1+\frac{x}{2\pi})(1-\frac{x}{3\pi})(1+\frac{x}{3\pi})...$&lt;/center&gt;&lt;br&gt;​                        &lt;center&gt;$=(1-\frac{x^2}{\pi^2})(1-\frac{x^2}{4\pi^2})(1-\frac{x^2}{9\pi^2})...$&lt;/center&gt;&lt;br&gt;​    （Euler 似乎并没有证明这个因式分解的正确性。幸运的是，一个世纪以后，Weierstrass 提出了著名的 Weierstrass 分解定理，利用复分析证明了这个结论。）&lt;br&gt;​    考虑这个因式分解的 $x^2$ 项前系数，对比泰勒展开式，可以知道&lt;br&gt;​                    &lt;center&gt;$-(\frac{1}{\pi^2}+\frac{1}{4\pi^2}+\frac{1}{9\pi^2}+...)=-\frac{1}{3!}=-\frac{1}{6}$&lt;/center&gt;&lt;br&gt;​    两边同乘 $-\pi^2$ 即&lt;br&gt;​                    &lt;center&gt;$\sum_{n \geq 1} \frac{1}{n^2}=\frac{\pi^2}{6}$&lt;/center&gt;&lt;br&gt;​    证毕&lt;br&gt;
    
    </summary>
    
      <category term="数学随笔" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6%E9%9A%8F%E7%AC%94/"/>
    
      <category term="数论" scheme="http://blog.rabbit-lb.cn/categories/%E6%95%B0%E5%AD%A6%E9%9A%8F%E7%AC%94/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数学" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="http://blog.rabbit-lb.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
